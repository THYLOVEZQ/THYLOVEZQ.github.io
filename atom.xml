<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>THYLOVEZJ的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-15T06:19:08.948Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>THYLOVEZJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>二叉搜索子树的最大键值和</title>
    <link href="http://example.com/2022/01/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%AE%E5%80%BC%E5%92%8C/"/>
    <id>http://example.com/2022/01/15/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E5%AD%90%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E9%94%AE%E5%80%BC%E5%92%8C/</id>
    <published>2022-01-15T06:02:19.000Z</published>
    <updated>2022-01-15T06:19:08.948Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。</p><p>二叉搜索树的定义如下：</p><p>任意节点的左子树中的键值都 小于 此节点的键值。<br>任意节点的右子树中的键值都 大于 此节点的键值。<br>任意节点的左子树和右子树都是二叉搜索树。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,4,3,2,4,2,5,null,null,null,null,null,null,4,6]</span><br><span class="line">输出：20</span><br><span class="line">解释：键值为 3 的子树是和最大的二叉搜索树。</span><br></pre></td></tr></table></figure><p>思路:</p><p>本题首先想到，我们应该判断一棵子树，看其是否为二叉搜索树。如果是二叉搜索树，则记录二叉搜索树的最大键值和。可以想到如果使用前序遍历，该题将不易求解</p><p>如果使用前序遍历</p><p>第一步我们需要判断其左右子树是否为二叉搜索树，如果不是，那么以root为节点的树肯定不为二叉搜索树。</p><p>第二步如果左右子树都为二叉搜索树，那么我们需要判断加上根节点是否仍为二叉搜索树</p><p>第三步要判断加上根节点是否为二叉搜索树，我们需要知道左子树的最大值和右子树的最小值</p><p>第四步判断左子树的最大值是否小于根节点，右子树的最小值是否大于根节点</p><p>最后计算二叉搜索树的最大键值和</p><p>而后续遍历，则可以直接计算以上函数。</p><p>下面是改为后序遍历的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSumBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] traverse(TreeNode root)&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//这里存储了4个参数。第一个是该二叉树是否为BST，第二个是二叉树的最小值，第三个是二叉树的最大值，第四个是BST的所有节点之和。</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,Integer.MAX_VALUE,Integer.MIN_VALUE,<span class="number">0</span>&#125;;    </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] leftTree = traverse(root.left);</span><br><span class="line">        <span class="keyword">int</span>[] rightTree = traverse(root.right);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//声明一个res</span></span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//判断根节点的二叉树是否为二叉搜索树</span></span><br><span class="line">        <span class="keyword">if</span>(leftTree[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;rightTree[<span class="number">0</span>]==<span class="number">1</span>&amp;&amp;rightTree[<span class="number">1</span>]&gt;root.val&amp;&amp;leftTree[<span class="number">2</span>]&lt;root.val)&#123;</span><br><span class="line">            res[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">            res[<span class="number">1</span>]=Math.min(root.val,leftTree[<span class="number">1</span>]);</span><br><span class="line">            res[<span class="number">2</span>]=Math.max(root.val,rightTree[<span class="number">2</span>]);</span><br><span class="line">            res[<span class="number">3</span>]+=root.val+leftTree[<span class="number">3</span>]+rightTree[<span class="number">3</span>];</span><br><span class="line">            ans = Math.max(res[<span class="number">3</span>],ans);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            res[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;给你一棵以 root 为根的 二叉树 ，请你返回 任意 二叉搜索子树的最大键值和。&lt;/p&gt;
&lt;p&gt;二叉搜索树的定义如下：&lt;/p&gt;
&lt;p&gt;任意节点的左子树中的键值都 小于 此节点的键值。&lt;br&gt;
任意节点的右子树中的键值都 大于 此节点的键值。&lt;br</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>不同的二叉搜索树</title>
    <link href="http://example.com/2022/01/14/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://example.com/2022/01/14/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2022-01-14T04:51:55.000Z</published>
    <updated>2022-01-14T07:39:44.845Z</updated>
    
    <content type="html"><![CDATA[<h3 id="不同的二叉搜索树II">不同的二叉搜索树II</h3><blockquote><p>给你一个整数 <code>n</code> ，请你生成并返回所有由 <code>n</code> 个节点组成且节点值从 <code>1</code> 到 <code>n</code> 互不相同的不同 <strong>二叉搜索树</strong> 。可以按 <strong>任意顺序</strong> 返回答案。</p></blockquote><p><img src="D:%5Cthy123%5Csource%5Cimg%5C8.jpg" alt=""></p><blockquote><p>输入：n = 3<br>输出：[[1,null,2,null,3],[1,null,3,2],[2,1,3],[3,1,null,null,2],[3,2,null,1]]</p></blockquote><p>解题思路:</p><p>我们可以让<strong>i</strong>作为根节点，那么i可以从1到n。当i作为根节点时，[1,i-1]既是二叉树的左子树，[i+1,n]是二叉树的右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">generateTrees</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">return</span> build(<span class="number">1</span>,n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//该函数用来构建一个范围在[l0,h0]的二叉搜索树</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">build</span><span class="params">(<span class="keyword">int</span> l0,<span class="keyword">int</span> h0)</span></span>&#123;</span><br><span class="line">    <span class="comment">//声明一个List用来存储所有可能的结果</span></span><br><span class="line">    List&lt;TreeNode&gt; list = <span class="keyword">new</span> ArrayList&lt;TreeNode&gt;();</span><br><span class="line">    <span class="comment">//这里的base case需要注意，如果左边界大于右边界时，给list添加null返回，为什么不直接返回null？</span></span><br><span class="line">        <span class="keyword">if</span>(l0&gt;h0)&#123;</span><br><span class="line">            list.add(<span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">return</span> list;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(i=l0,i&lt;=h0;i++)&#123;</span><br><span class="line">            TreeNode leftTrees = build(l0,i-<span class="number">1</span>);</span><br><span class="line">            TreeNode rightTrees = build(i+<span class="number">1</span>,h0);</span><br><span class="line">            <span class="keyword">for</span>(TreeNode leftTree:leftTrees)&#123;</span><br><span class="line">                <span class="keyword">for</span>(TreeNode rightTree:rightTrees)&#123;</span><br><span class="line">                    TreeNode root = <span class="keyword">new</span> TreeNode(i);</span><br><span class="line">                    root.left = leftTree;</span><br><span class="line">                    root.right = rightTree;</span><br><span class="line">                    list.add(root);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;不同的二叉搜索树II&quot;&gt;不同的二叉搜索树II&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; ，请你生成并返回所有由 &lt;code&gt;n&lt;/code&gt; 个节点组成且节点值从 &lt;code&gt;1&lt;/code&gt; 到 &lt;code&gt;n&lt;/co</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>二叉树的插入</title>
    <link href="http://example.com/2022/01/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5/"/>
    <id>http://example.com/2022/01/13/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5/</id>
    <published>2022-01-13T02:29:44.000Z</published>
    <updated>2022-01-13T03:46:41.908Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉树的插入">二叉树的插入</h3><blockquote><p>给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。</p><p>注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果 。</p></blockquote><p><img src="D:%5Cthy123%5Csource%5Cimg%5C7.jpg" alt=""></p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure></blockquote><p>首先，我们应该知道，二叉树的构建肯定不止一种，而我们这种算法只能模拟一种二叉树的插入</p><p>我们可以利用一个pos指针指向root，base case为当pos指针为空时返回</p><p>当val值小于pos.val时，去寻找pos节点的左子树，当val值大于pos.val时，去寻找pos节点的右子树</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">insertIntoBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        TreeNode pos = root;</span><br><span class="line">        <span class="keyword">if</span>(pos==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(val&lt;pos.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.left==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos.left = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;    </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    pos=pos.left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(val&gt;pos.val)&#123;</span><br><span class="line">                <span class="keyword">if</span>(pos.right==<span class="keyword">null</span>)&#123;</span><br><span class="line">                    pos.right = <span class="keyword">new</span> TreeNode(val);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                pos=pos.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除二叉搜索树中的节点">删除二叉搜索树中的节点</h3><blockquote><p>给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。</p><p>一般来说，删除节点可分为两个步骤：</p><p>首先找到需要删除的节点；<br>如果找到了，删除它。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,3,6,2,4,null,7], key = 3</span><br><span class="line">输出：[5,4,6,2,null,null,7]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode left;</span><br><span class="line"> *     TreeNode right;</span><br><span class="line"> *     TreeNode() &#123;&#125;</span><br><span class="line"> *     TreeNode(int val) &#123; this.val = val; &#125;</span><br><span class="line"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode deleteNode(TreeNode root, int key) &#123;</span><br><span class="line">        if(root == null)return null;</span><br><span class="line">        //如果root.val==key值，则说明找到了root节点 </span><br><span class="line">        if(root.val == key)&#123;</span><br><span class="line">            //如果根节点的左子树为空，那么直接将右子树返回即可</span><br><span class="line">            if(root.left==null)return root.right;</span><br><span class="line">            //如果根节点的右子树为空，那么直接将二叉树的左子树返回即可</span><br><span class="line">            if(root.right==null)return root.left;</span><br><span class="line">            //如果root的左右子树都不为空，则需要将左子树最大的元素返回，或者右子树最小的元素返回,我们这里去寻找右子树最小的元素进行返回</span><br><span class="line">            TreeNode minVal = getMinVal(root.right);</span><br><span class="line">            root.val = minVal.val;</span><br><span class="line">            root.right = deleteNode(root.right,minVal.val);              </span><br><span class="line">        &#125;</span><br><span class="line">        //在这里时，root的值并不等于key,那么我们需要去寻找节点值等于key的元素</span><br><span class="line">        else if(root.val&lt;key)&#123;</span><br><span class="line">            root.right = deleteNode(root.right,key);</span><br><span class="line">        &#125;</span><br><span class="line">        else if(root.val&gt;key)&#123;</span><br><span class="line">            root.left = deleteNode(root.left,key);</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    //寻找二叉树中最小的值,二叉树中最小的值就是最左边的节点</span><br><span class="line">    public TreeNode getMinVal(TreeNode root)&#123;</span><br><span class="line">        while(root.left!=null)&#123;</span><br><span class="line">            root=root.left;</span><br><span class="line">        &#125;</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉树的插入&quot;&gt;二叉树的插入&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定二叉搜索树（BST）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。&lt;/p&gt;
&lt;p&gt;注意，可能存</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>JSP与Servlet进阶</title>
    <link href="http://example.com/2022/01/11/JSP%E4%B8%8EServlet%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2022/01/11/JSP%E4%B8%8EServlet%E8%BF%9B%E9%98%B6/</id>
    <published>2022-01-11T09:30:12.000Z</published>
    <updated>2022-01-14T18:10:37.499Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用请求头开发多端应用">利用请求头开发多端应用</h3><p>下面的代码模拟了利用请求头的不同识别不同的主机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovezj.www;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/au&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAgentServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String userAgent = request.getHeader(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">        <span class="comment">//设置中文显示</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        String output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(userAgent.indexOf(<span class="string">&quot;Windows&quot;</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">            output = <span class="string">&quot;&lt;h1&gt;这是PC端首页&lt;/h1&gt;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;iPhone&quot;</span>)!=-<span class="number">1</span>||userAgent.indexOf(<span class="string">&quot;Android&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            output = <span class="string">&quot;&lt;h1&gt;这是移动端首页&lt;/h1&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().println(output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="响应的结构">响应的结构</h3><p>HTTP响应包含三个部分:响应行，响应头，响应体</p><table><thead><tr><th>状态码</th><th>错误描述</th></tr></thead><tbody><tr><td>200</td><td>服务器处理成功</td></tr><tr><td>404</td><td>无法找到文件</td></tr><tr><td>500</td><td>内部服务器错误</td></tr><tr><td>403</td><td>服务器拒绝访问</td></tr><tr><td>301，302</td><td>请求重定向</td></tr><tr><td>400</td><td>无效的请求</td></tr><tr><td>401</td><td>未经过授权</td></tr><tr><td>503</td><td>服务器超负载或正停机维护，无法处理请求</td></tr></tbody></table><h3 id="ContentType的作用">ContentType的作用</h3><table><thead><tr><th>MIME类型</th><th>描述</th></tr></thead><tbody><tr><td>text/plain</td><td>纯文本</td></tr><tr><td>text/html</td><td>HTML文档</td></tr><tr><td>text/xml</td><td>XML文档</td></tr><tr><td>application/x-msdownload</td><td>需要下载的资源</td></tr><tr><td>image/jpeg    image/gif   …</td><td>图片资源</td></tr></tbody></table><h3 id="请求的转发与响应重定向">请求的转发与响应重定向</h3><p>多个Servlet(JSP)之间跳转有两种方式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher().forward()-请求转发</span><br><span class="line"></span><br><span class="line">response.sendRediret()-响应重定向</span><br></pre></td></tr></table></figure><p>其中请求转发是服务器的跳转，只产生一次请求</p><p>浏览器-&gt;Tomcat(Tomcat在内部执行完Servlet1然后把请求发给Servlet2)-&gt;响应</p><p>而响应重定向则是浏览器跳转，会产生两次请求</p><p>浏览器-&gt;Servlet1-&gt;响应-&gt;请求2-&gt;Servlet2-&gt;响应2</p><h3 id="设置请求自定义属性">设置请求自定义属性</h3><p>请求允许创建自定义属性</p><p>设置请求属性：request.setAttribute(属性名,属性值)</p><p>获取请求属性：Object attr = request.getAttribute(属性名)</p><h3 id="浏览器Cookie">浏览器Cookie</h3><p>Cookie(小甜饼)是浏览器保存在本地的文本内容</p><p>Cookie常用于保存登录状态，用户资料等小文本</p><p>Cookie具有时效性，Cookie内容会伴随着请求发给Tomcat</p><p>在下面我们定义了两个servlet用来模拟用户的登录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovezj.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/cookies/login&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">thyLoginServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;用户登录成功&quot;</span>);</span><br><span class="line">        Cookie cookie = <span class="keyword">new</span> Cookie(<span class="string">&quot;user&quot;</span>,<span class="string">&quot;admin&quot;</span>);</span><br><span class="line">        response.addCookie(cookie);</span><br><span class="line">        response.getWriter().print(<span class="string">&quot;login success&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovezj.cookie;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.Cookie;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/cookies/index&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">thyIndexServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"><span class="comment">//        response.setContentType(&quot;text/html;charset=utf-8&quot;);</span></span><br><span class="line">        Cookie[] cookies = request.getCookies();</span><br><span class="line">        String user = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (cookies == <span class="keyword">null</span>)&#123;</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;user not login&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(Cookie cookie:cookies)&#123;</span><br><span class="line">            System.out.println(cookie.getName()+<span class="string">&quot;  &quot;</span>+cookie.getValue());</span><br><span class="line">            <span class="keyword">if</span> (cookie.getName().equals(<span class="string">&quot;user&quot;</span>))&#123;</span><br><span class="line">                user = cookie.getValue();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span>)&#123;</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;user not login&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            response.getWriter().print(<span class="string">&quot;user:  &quot;</span> +user);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>值得注意的是，如果我们不设置cookie的存在时间，我们默认有效期是当前的浏览器窗口</p><p>因此，我们需要给cookie设置有效时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置Cookie有效时间</span></span><br><span class="line">cookie.setMaxAge(<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">7</span>);</span><br></pre></td></tr></table></figure><h3 id="Session-用户会话">Session-用户会话</h3><p>Session(用户会话)用于保存与&quot;浏览器窗口&quot;对应的数据</p><p>Session的数据存储在Tomcat服务器的内存中，具有时效性</p><p>Session通过浏览器Cookie的SessionId值提取用户数据</p><h3 id="ServletContext对象">ServletContext对象</h3><p>ServletContext(Servlet上下文对象)，是Web应用全局对象</p><p>一个Web应用只会创建一个ServletContext对象</p><p>ServletContext随着Web应用启动而自动创建</p><h3 id="Java-Web三大作用域对象">Java Web三大作用域对象</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest-请求对象</span><br><span class="line">生命周期最短</span><br><span class="line">HttpSession-用户会话对象</span><br><span class="line">30分钟没有访问就会销毁</span><br><span class="line">ServletContext-web应用全局对象</span><br><span class="line">web应用程序关闭或者重启销毁</span><br></pre></td></tr></table></figure><p>用小不用大</p><h3 id="Web应用程序的中文乱码由来">Web应用程序的中文乱码由来</h3><p>Tomcat默认使用字符集ISO-8859-1，属于西欧字符集</p><p>解决乱码核心就是将ISO-8859-1转换为UTF-8</p><p>Servlet的请求与响应都需要设置UTF-8字符集</p><p>请求处理方式:</p><p>处理<strong>POST</strong>请求中中文乱码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.setCharacterEncoding(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure><p>处理<strong>GET</strong>请求中中文乱码</p><p><strong>对于Tomcat8.X以上版本无需处理</strong></p><h3 id="web-xml常用配置">web.xml常用配置</h3><p>修改web应用默认首页</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://java.sun.com/xml/ns/javaee</span></span></span><br><span class="line"><span class="string"><span class="tag">  http://java.sun.com/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">version</span>=<span class="string">&quot;4.0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--设置web应用首页--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="name">welcome-file</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">welcome-file-list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Servlet通配符映射及初始化参数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>pattern<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.thylovezj.servlet.pattern.Pattern<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>pattern<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--*可以匹配到任何数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/pattern/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置404，500等状态码默认页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/error/404.html<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JSP的九大内置对象">JSP的九大内置对象</h3><table><thead><tr><th>内置对象</th><th>描述</th></tr></thead><tbody><tr><td>request</td><td>请求对象-HttpServletRequest</td></tr><tr><td>response</td><td>响应对象-HttpServletResponse</td></tr><tr><td>session</td><td>用户会话-HttpSession</td></tr><tr><td>application</td><td>应用全局对象-ServletContext</td></tr><tr><td>out</td><td>输出对象-PrintWriter</td></tr><tr><td>page</td><td>当前页面对象-this</td></tr><tr><td>pageContext</td><td>页面上下文对象-PageContext</td></tr><tr><td>config</td><td>应用配置对象-ServletConfig</td></tr><tr><td>exception</td><td>应用异常对象-Throwable</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;利用请求头开发多端应用&quot;&gt;利用请求头开发多端应用&lt;/h3&gt;
&lt;p&gt;下面的代码模拟了利用请求头的不同识别不同的主机&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>JSP入门</title>
    <link href="http://example.com/2022/01/11/JSP%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/11/JSP%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-11T07:41:58.000Z</published>
    <updated>2022-01-11T09:28:35.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Servlet开发的痛点">Servlet开发的痛点</h3><p>静态的HTML与动态Java代码混合在一起，难以维护</p><p>Servlet利用out.println()语句输出，开发效率低下</p><p>Eclipse很难在开发过程中发现错误，调试困难</p><h3 id="JSP介绍">JSP介绍</h3><p>JSP全称是(Java Server Pages),Java服务器页面</p><p>JSP是J2EE的功能模块，由Web服务器执行</p><p>JSP的作用就是降低动态网页开发难度</p><h3 id="JSP的特点">JSP的特点</h3><p>JSP使用简单，短时间学习便可上手使用</p><p>JSP可将Java代码与HTML分离，降低开发难度</p><p>JSP的本质就是Servlet</p><h3 id="JSP的运行要求">JSP的运行要求</h3><p>可正常的Tomcat</p><p>所有JSP页面扩展名必须是.jsp</p><p>JSP页面应该放在Web应用程序目录下</p><h3 id="第一段JSP代码">第一段JSP代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: THY</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">1</span>/<span class="number">11</span></span><br><span class="line">  Time: <span class="number">16</span>:<span class="number">00</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;year&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;salary&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> salary = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">                salary = <span class="number">1500</span>+i*<span class="number">150</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">5</span> &amp;&amp; i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">                salary = <span class="number">1500</span>+<span class="number">150</span>*<span class="number">5</span>+<span class="number">300</span>*(i-<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">10</span>)&#123;</span><br><span class="line">                salary = <span class="number">1500</span>+<span class="number">150</span>*<span class="number">5</span>+<span class="number">300</span>*<span class="number">5</span>+<span class="number">375</span>*(i-<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;td&gt;&quot;</span>+ i +<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;td&gt;&quot;</span>+ salary +<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JSP执行过程">JSP执行过程</h3><p>浏览器给Tomcat发请求-&gt;Tomcat将JSP转译为Servlet源代码-&gt;Java对其进行编译生成Servlet字节码</p><h3 id="JSP基本语法">JSP基本语法</h3><p>JSP语法十分简单，按功能可分为以下几种</p><p>1.JSP代码块</p><p>2.JSP声明构造块</p><p>3.JSP输出指令</p><p>4.JSP处理指令</p><p>JSP代码块用于在JSP中嵌入Java代码</p><p>JSP代码语法块:&lt;% java代码 %&gt;</p><p>JSP声明构造块用于声明变量或者方法</p><p>JSP声明构造块语法:&lt;%!声明语句%&gt;</p><p>例如:&lt;%!public int add(int a,int b){return a+b;}%&gt;</p><p>JSP输出指令</p><p>JSP输出指令用于在JSP页面中显示java代码执行结果</p><p>JSP输出指令语法:&lt;%=java代码%&gt;</p><p>例如:&lt;%=“&lt; b &gt;”+name+“&lt; /b &gt;”%&gt;</p><p>JSP处理指令</p><p>JSP处理指令用于提供JSP执行过程中的辅助信息</p><p>JSP处理指令语法:&lt; %@jsp指令% &gt;</p><p>例如:&lt;%@ page import=“java.util.*” %&gt;</p><h3 id="JSP常用处理指令">JSP常用处理指令</h3><p>&lt;%@ page %&gt;定义当前JSP页面全局设置</p><p>&lt;%@ include %&gt;将其他JSP页面与当前JSP页面合并</p><p>&lt;%@ taglib %&gt;引入JSP标签库</p><h3 id="JSP中注释的区别">JSP中注释的区别</h3><p>&lt;%-- 注释 --%&gt;JSP注释，被注释语句不做任何处理</p><p>// , /* … */用于注释&lt;%%&gt;java代码，被注释代码不执行</p><!-- html -->HTML注释，被注释的语句不会被浏览器解释<h3 id="JSP页面重用">JSP页面重用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@include file=&quot;include/header.jsp&quot;%&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Servlet开发的痛点&quot;&gt;Servlet开发的痛点&lt;/h3&gt;
&lt;p&gt;静态的HTML与动态Java代码混合在一起，难以维护&lt;/p&gt;
&lt;p&gt;Servlet利用out.println()语句输出，开发效率低下&lt;/p&gt;
&lt;p&gt;Eclipse很难在开发过程中发现错误，调试</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="http://example.com/2022/01/11/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://example.com/2022/01/11/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2022-01-11T04:56:33.000Z</published>
    <updated>2022-01-11T06:47:55.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="验证二叉搜索树">验证二叉搜索树</h3><blockquote><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></blockquote><p>思路:</p><p>​验证一个二叉树是BST，即要求二叉树的左子树比二叉树的根节点值小，二叉树的右子树比根节点值大。那么我们可以写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意，当只有一个节点时，肯定为二叉搜索树，所以直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.val&lt;=root.left.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>&amp;&amp;root.val&gt;=root.right.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        isValidBST(root.left);</span><br><span class="line">        isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样的代码是存在漏洞的，比如当此时，该二叉树少了根节点的约束。</p><p><img src="D:%5Cthy123%5Csource%5Cimg%5C5.png" alt=""></p><p>因此，我们需要添加根节点的约束，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isValidBST(root,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root,TreeNode min,TreeNode max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(min!=<span class="keyword">null</span>&amp;&amp;root.val&lt;=min.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(max!=<span class="keyword">null</span>&amp;&amp;root.val&gt;=max.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left,min,root)&amp;&amp;isValidBST(root.right,root,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在BST中搜索一个数">在BST中搜索一个数</h3><blockquote><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2     </span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></blockquote><p>本题虽然不难，但是需要注意一些细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val==val)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//由于是BST我们可以加上一些判断条件，使其寻找正确的子树</span></span><br><span class="line">        <span class="comment">//当val小于根节点的值时，我们应该遍历左子树去寻找val，当val大于根节点的值时，我们应该遍历右子树去寻找val</span></span><br><span class="line">        <span class="keyword">if</span>(val&lt;root.val)<span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="comment">//这里需要注意，不能写为两个if，否则编译器会报错。</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有本题需要注意，我们如何返回一个子树，即给递归加上return。</p><h3 id=""></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;验证二叉搜索树&quot;&gt;验证二叉搜索树&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;有效 二叉搜索树定义如下：&lt;/p&gt;
&lt;p&gt;节点的左子树只包含 小于 当前节点的数。&lt;br&gt;
节点的右子</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>把二叉搜索树转换为累加树</title>
    <link href="http://example.com/2022/01/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <id>http://example.com/2022/01/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</id>
    <published>2022-01-10T04:08:48.000Z</published>
    <updated>2022-01-10T04:08:48.658Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树中第K小的元素</title>
    <link href="http://example.com/2022/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2022-01-10T03:43:14.000Z</published>
    <updated>2022-01-10T03:54:03.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉搜索树中第K小的元素">二叉搜索树中第K小的元素</h3><blockquote><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><p><strong>二叉搜索树的中序遍历是有顺序的二叉树</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> ans=<span class="number">0</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        traverse(root,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left,k);</span><br><span class="line">        key++;</span><br><span class="line">        <span class="keyword">if</span>(key == k)&#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉搜索树中第K小的元素&quot;&gt;二叉搜索树中第K小的元素&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉搜索树的根节点 &lt;code&gt;root&lt;/code&gt; ，和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你设计一个算法查找其中第 &lt;code&gt;k&lt;/code&gt; </summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Servlet入门</title>
    <link href="http://example.com/2022/01/09/Servlet%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/09/Servlet%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-09T13:41:51.000Z</published>
    <updated>2022-01-11T10:17:19.233Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是CS架构-Client-server">什么是CS架构(Client-server)</h3><p>Client/Sever结构(C/S结构)是指客户端和服务器结构</p><p>优点:数据方便共享，安全性高</p><p>缺点:必须安装客户端，升级与维护困难</p><h3 id="互联网时代-Browser-Server模式">互联网时代(Browser-Server模式)</h3><p>Browser-Server(B/S)模式即浏览器和服务器架构模式</p><p>优点:开发简单，无需安装客户端，数据易于共享</p><p>缺点:相较于C/S模式，执行速度与用户体验相对较弱。</p><h3 id="B-S模式执行流程">B/S模式执行流程</h3><p>用户输入baidu.com-&gt;浏览器根据输入的域名解析成IP地址(DNS协议)-&gt;WEB服务器&lt;-&gt;服务器程序</p><h3 id="请求与响应">请求与响应</h3><p>从浏览器发送给服务器的数据包称为请求Request</p><p>从服务器返回给浏览器的结果称为响应response</p><h3 id="J2EE是什么">J2EE是什么</h3><p>J2EE是指Java2企业版</p><p>开发BS(Web)应用程序就是J2EE最核心的功能</p><p>J2EE由13个功能模块组成</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>Servlet</td><td>Web服务器小程序</td></tr><tr><td>JSP</td><td>服务器页面</td></tr><tr><td>JDBC</td><td>数据库交互模块</td></tr><tr><td>XML</td><td>XML交互模块</td></tr><tr><td>EJB</td><td>企业级Java Bean</td></tr><tr><td>RMI</td><td>远程调用</td></tr><tr><td>JNDI</td><td>目录服务</td></tr><tr><td>JMS</td><td>消息服务</td></tr><tr><td>JTA</td><td>事务管理</td></tr><tr><td>JavaMail</td><td>发送/接收Email</td></tr><tr><td>JAF</td><td>安全框架</td></tr><tr><td>CORBA</td><td>CORBA集成</td></tr><tr><td>JTS</td><td>CORBA事务监控</td></tr></tbody></table><h3 id="Apache-Tomcat">Apache Tomcat</h3><p>Tomcat是Apache软件基金会下一款免费的开放源代码的Web应用服务器程序</p><h3 id="J2EE和Tomcat的关系">J2EE和Tomcat的关系</h3><p>J2EE是一组技术规范与指南，具体实现由软件厂商决定</p><p>Tomcat是J2EE Web(servlet与JSP)标准的实现者</p><p>J2SE是J2EE运行的基石，运行Tomcat离不开J2SE</p><h3 id="Servlet">Servlet</h3><p>Servlet(Servlet Applet)服务器小程序，主要用于生成Web内容</p><p>Servlet是J2EE最重要的组成部分，也是我们学习的重点</p><h3 id="Tomcat的安装与运行">Tomcat的安装与运行</h3><p>Tomcat下载去Tomcat官网下载，版本要根据JDK版本确定，如果JDK为8，那么就需要采用Tomcat8的版本</p><p>安装下来以后，需要配置JDK的环境变量JAVA_HOME</p><p>然后在命令行进入Tomcat的bin目录下输入startup.bat，然后访问localhost:8080，如果能出现Tomcat的官网，则说明配置完成</p><h3 id="Tomcat日志乱码">Tomcat日志乱码</h3><p>参考博客</p><p><a href="https://blog.csdn.net/peanut_trees/article/details/106716045">解决乱码</a></p><h3 id="发现8080端口被占怎么办">发现8080端口被占怎么办</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询8080端口进程pid</span><br><span class="line">netstat -ano|findstr 8080</span><br></pre></td></tr></table></figure><h3 id="第一个Servlet程序">第一个Servlet程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovexj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HttpServlet是所有小程序的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法里由两个参数，第一个参数是Http请求，第二个是Http响应</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//接收请求发来的参数</span></span><br><span class="line">        String name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String html = <span class="string">&quot;&lt;h1&gt;&quot;</span>+name+<span class="string">&quot;&lt;/h1&gt;&quot;</span>;</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>XML需要进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>first<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.thylovexj.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--这里视频上有误，新版的不用加文件名，直接使用url-pattern就OK了，同时记得每次修改完了要重新上传--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>first<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hi<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完后，启动Tomcat服务器即可在<a href="">localhost:8080/hi</a>访问第一个servlet程序</p><h3 id="标准的Java-Web工程结构">标准的Java Web工程结构</h3><table><thead><tr><th>组织结构</th><th>描述</th></tr></thead><tbody><tr><td>tomcat安装目录/webapps</td><td>Tomcat应用根目录</td></tr><tr><td>/web应用目录/</td><td>Java Web应用目录</td></tr><tr><td>/web应用目录/index.html|.jsp</td><td>默认首页</td></tr><tr><td>/WEB-INF</td><td>WEB应用的安全目录，用来存放配置文件</td></tr><tr><td>/WEB-INF/web.xml</td><td>web.xml是&quot;部署描述符文件&quot;，是该Web项目的核心文件</td></tr><tr><td>/WEB-INF/classes</td><td>存放编译后的classes文件</td></tr><tr><td>/WEB-INF/lib</td><td>用于存放WEB应用依赖的jar文件</td></tr><tr><td>/META-INF/MANIFEST.MF</td><td>包含Web应用的版本信息</td></tr></tbody></table><h3 id="Servlet开发步骤">Servlet开发步骤</h3><blockquote><p>创建Servlet类，集成HttpServlet</p><p>重写service方法，编写程序代码</p><p>配置web.xml，绑定URL</p></blockquote><h3 id="请求参数">请求参数</h3><blockquote><p>请求参数是指浏览器通过请求向Tomcat提交的数据</p><p>请求参数通常是用户输入的数据，待Servlet进行处理</p><p>参数名1=值1&amp;参数名2=值2&amp;参数名3=值3</p></blockquote><h3 id="Servlet接收请求参数">Servlet接收请求参数</h3><p>前端通过form标签里的属性里的action=“URL”将数据提交给后端</p><p>URL是servlet绑定的地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收单个参数</span></span><br><span class="line">request.getParameter();</span><br><span class="line"><span class="comment">//接收多个同名参数</span></span><br><span class="line">request.getParameterValues();</span><br></pre></td></tr></table></figure><p>下面的代码展示了html提交的数据，在浏览器上显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>学员信息登记表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/servletTest_war_exploded/sample&quot;</span>&gt;</span></span><br><span class="line">    姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    电话<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    特长</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;English&quot;</span>&gt;</span>英语</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Math&quot;</span>&gt;</span>数学</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Chinese&quot;</span>&gt;</span>语文</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovexj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        String name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String mobile = req.getParameter(<span class="string">&quot;mobile&quot;</span>);</span><br><span class="line">        String[] specs = req.getParameterValues(<span class="string">&quot;spec&quot;</span>);</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;h1&gt;name:&quot;</span>+name+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;h1&gt;mobile:&quot;</span>+mobile+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String spe:specs)&#123;</span><br><span class="line">            writer.println(spe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Get与Post请求方法">Get与Post请求方法</h3><p>Get方式是将数据通过在URL附加数据显性向服务器发送数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/FirServlet/sample?name=zhangsan</span><br></pre></td></tr></table></figure><p>Post方式会将数据存放在“请求体”中隐性向服务器发送数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/FirstServlet/sample</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求体:name=zhangsan</span><br></pre></td></tr></table></figure><p>默认我们提交表单是使用<strong>Get</strong>方法提交，而如果我们要改变方法，可以利用html表单里<strong>method()方法</strong>的<strong>Post</strong>属性提交表单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doPost()方法只处理Post请求</span><br><span class="line">doGet()方法只处理Get请求</span><br></pre></td></tr></table></figure><h3 id="Get方法和Post方法应用场景">Get方法和Post方法应用场景</h3><blockquote><p>Get常用于不包含敏感信息的查询功能</p></blockquote><blockquote><p>Post用于安全性要求较高的功能或者服务器的写操作</p></blockquote><p>用户登录</p><p>用户注册</p><p>更新公司账目</p><h3 id="Servlet生命周期">Servlet生命周期</h3><p>装载-web.xml</p><p>创建-构造函数第一次访问servlet</p><p>初始化-init()</p><p>提供服务-service()</p><p>销毁-destroy()</p><p><strong>如果刷新页面，只会提供服务，并不会再次创建Servlet对象。</strong></p><h3 id="使用注解简化配置">使用注解简化配置</h3><p>Servlet3.x之后引入了&quot;注解Annotation&quot;特性</p><p>注解用于简化Web应用程序的配置过程</p><p>Servlet核心注解:@WebServlet</p><h3 id="启动时加载Servlet">启动时加载Servlet</h3><p>web.xml使用&lt; load-on-startup &gt;设置启动时加载</p><p>&lt; load-on-startup &gt;0-9999&lt;/ load-on-startup &gt;</p><p>启动时加载在工作中常用于系统的预处理</p><h3 id="在注解设置启动加载">在注解设置启动加载</h3><p>@WebServlet(urlPattern,loadOnStartup=2)</p><p>必须要设置urlPattern,否则不会加载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是CS架构-Client-server&quot;&gt;什么是CS架构(Client-server)&lt;/h3&gt;
&lt;p&gt;Client/Sever结构(C/S结构)是指客户端和服务器结构&lt;/p&gt;
&lt;p&gt;优点:数据方便共享，安全性高&lt;/p&gt;
&lt;p&gt;缺点:必须安装客户端，升级与维护</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>寻找重复的子树</title>
    <link href="http://example.com/2022/01/09/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>http://example.com/2022/01/09/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/</id>
    <published>2022-01-09T04:50:56.000Z</published>
    <updated>2022-01-09T05:15:04.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p></blockquote><p>这道题的思路是:</p><p>首先可以想到我们需要声明一个List用来返回根节点</p><p>其次我们应该想到，我们需要一个函数用来收集不同根节点时的左右子树,即下面所示代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">collect(root);</span><br></pre></td></tr></table></figure><p>那么，这些子树应该使用一个Set集合来收集。当遇到新的子树时，往里添加子树。而子树可以将其序列化为字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>接下来，我们将对collect函数进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Collect</span><span class="params">(Tree root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果根节点为空，则返回&quot;#&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String left = Collect(root.left);</span><br><span class="line">    String right = Collect(root.right);</span><br><span class="line">    <span class="comment">//将二叉树序列化为字符串</span></span><br><span class="line">    String subtree = left+<span class="string">&quot;,&quot;</span>+right+<span class="string">&quot;,&quot;</span>+root.val;</span><br><span class="line">    <span class="comment">//查看Set中是否含有subtree，如果没有则添加subtree，如果有则将其根节点添加到list中。</span></span><br><span class="line">    <span class="keyword">if</span>(set.contains(subtree))&#123;</span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        set.add(subtree);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该函数返回的是root作为根节点时，二叉树的后序遍历。</span></span><br><span class="line">    <span class="keyword">return</span> suntree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里有个问题，如果有多个子树的根节点的val一样，则会重复添加，我们需要避免这种情况，因此，我们将HashSet改为HashMap记录subtree出现的次数。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String left = traverse(root.left);</span><br><span class="line">        String right = traverse(root.right);</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        String subtree = left+<span class="string">&#x27;,&#x27;</span>+right+<span class="string">&#x27;,&#x27;</span>+root.val;</span><br><span class="line">        <span class="keyword">int</span> fre = map.getOrDefault(subtree,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(fre == <span class="number">1</span>)&#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(subtree,fre+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里的返回，返回的是后序遍历的序列化的二叉树    </span></span><br><span class="line">        <span class="keyword">return</span> subtree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意&lt;strong&gt;一棵&lt;/strong&gt;的根结点即可。&lt;/p&gt;
&lt;p&gt;两棵树重复是指它们具有相同的结构以及相同的结点值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题的</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>判断回文单链表</title>
    <link href="http://example.com/2022/01/08/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/08/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-08T12:42:47.000Z</published>
    <updated>2022-01-08T12:55:46.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断回文单链表">判断回文单链表</h3><blockquote><p>给定一个链表的 <strong>头节点</strong> <code>head</code> **，**请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [1,2,3,3,2,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></blockquote><p>思路:刚开始的思路是新建一个链表，然后反转该链表，然后两个指针从前往后遍历，比较每个节点的值。如果相等则返回true，不相等则false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">ListNode left;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        left = head;</span><br><span class="line">        <span class="keyword">return</span> Palindrome(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Palindrome</span><span class="params">(ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boolean res = Palindrome(right.next);</span><br><span class="line">        <span class="comment">//后续遍历</span></span><br><span class="line">        res = res&amp;&amp;(right.val==left.val);</span><br><span class="line">        left = left.next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;判断回文单链表&quot;&gt;判断回文单链表&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表的 &lt;strong&gt;头节点&lt;/strong&gt; &lt;code&gt;head&lt;/code&gt; **，**请判断其是否为回文链表。&lt;/p&gt;
&lt;p&gt;如果一个链表是回文，那么链表节点序列从前往后</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://example.com/2022/01/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://example.com/2022/01/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2022-01-08T11:19:39.000Z</published>
    <updated>2022-01-08T11:27:11.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长回文子串">最长回文子串</h3><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure></blockquote><p>思路:</p><p>1.中心扩散法：定义两个指针，每次向外扩散一个字符，判断两个字符是否相等，直到遍历到最后一个节点或者最前面的节点。这里需要注意，如果该回文串是奇数。那么中间子符为一个，如果为偶数，则中间子符为两个。下面是代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String res = s.substring(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//找到以i为中心的回文子串</span></span><br><span class="line">            String len1 = Palindrome(s,i,i);</span><br><span class="line">            <span class="comment">//找到以i+1为中心的回文子串</span></span><br><span class="line">            String len2 = Palindrome(s,i,i+<span class="number">1</span>);</span><br><span class="line">            res = res.length()&gt;=len1.length()?res:len1;</span><br><span class="line">            res = res.length()&gt;=len2.length()?res:len2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Palindrome</span><span class="params">(String s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;s.length()&amp;&amp;s.charAt(l)==s.charAt(r))&#123;</span><br><span class="line">            l--;r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(l+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最长回文子串&quot;&gt;最长回文子串&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://example.com/2022/01/07/XML%E7%9A%84%E7%94%A8%E9%80%94/"/>
    <id>http://example.com/2022/01/07/XML%E7%9A%84%E7%94%A8%E9%80%94/</id>
    <published>2022-01-07T14:12:38.000Z</published>
    <updated>2022-01-09T13:39:23.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XML的用途">XML的用途</h3><blockquote><p>1.Java程序的配置描述文件</p><p>2.用于保存程序的产生的数据</p><p>3.网络间的数据传输</p></blockquote><h3 id="XML的文档结构">XML的文档结构</h3><blockquote><p>1.第一行必须是XML声明</p><p>2.有且只有一个根节点</p><p>3.XML标签的书写规则与HTML相同</p></blockquote><h3 id="XML声明">XML声明</h3><p>XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;</span></span><br></pre></td></tr></table></figure><p>version代表版本号，UTF-8设置字符集，用于支持中文</p><h3 id="XML标签书写规则">XML标签书写规则</h3><blockquote><p>合法的标签名</p><p>​标签名要有意义</p><p>​建议使用英文，小写字母，单词之间用“-”分隔</p><p>​建议多级标签之间不要存在重名的情况</p><p>适当的注释与缩进</p><p>​适当的注释与缩进可以让XML文档更加容易阅读</p><p>合理使用属性</p><p>​标签属性常用于描述标签不可或缺的信息</p><p>​对标签分组或者为标签设置id时常用属性表示</p><p>特殊子符与CDATA标签</p><p>​标签体中，出现&quot;&lt;“,”&gt;&quot;特殊子符，会破坏文档结构</p><p>​解决办法:使用实体引用</p><p>使用CDATA标签</p><table><thead><tr><th>实体引用</th><th>对应符号</th><th>说明</th></tr></thead><tbody><tr><td>&amp;It ;</td><td>&lt;</td><td>小于</td></tr><tr><td>&amp;gt ;</td><td>&gt;</td><td>大于</td></tr><tr><td>&amp;amp ;</td><td>&amp;</td><td>和号</td></tr><tr><td>&amp;apos ;</td><td>’</td><td>单引号</td></tr><tr><td>&amp;quot ;</td><td>‘’</td><td>双引号</td></tr></tbody></table><p>​CDATA指的是不应由XML解析器进行解析的文本数据</p><p>​从&quot;<![CDATA["开始，到"]]>&quot;结束</p><p>有序的子元素</p></blockquote><h3 id="XML语义约束">XML语义约束</h3><p>XML文档结构正确，但可能不是有效的。</p><p>​例如，员工档案XML中绝不允许出现&quot;植物品种标签&quot;。XML语义约束就是用于规定XML文档中允许出现哪些元素</p><p>XML语义约束有两种定义方式，<strong>DTD</strong>和<strong>XML Schema</strong></p><p><strong>DTD</strong>(Document Type Definition,文档类型定义)是一种简单易用的语义约束方式</p><p><strong>DTD</strong>文件的拓展名为.dtd</p><p>利用<strong>DTD</strong>中的&lt;!ELEMENT&gt;标签，我们可以定义XML文档中允许出现的节点和数量，以hr.xml为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义hr节点下只允许出现1个employee子节点</span><br><span class="line">&lt;!ELEMENT hr (employee)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">employee节点下必须包含四个节点，且按顺序出现</span><br><span class="line">&lt;!ELEMENT employee (name,age,salary,department)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义name标签体只能是文本，#PCDATA代表文本元素</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>如某个子节点需要多次重复出现，则需要在子节点后增加响应的描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hr节点下最少出现一个employee节点</span><br><span class="line">&lt;!ELEMENT hr (employee+)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hr节点下可出现0...n个employee子节点</span><br><span class="line">&lt;!ELEMENT hr (employee*)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hr节点下最多出现1个employee子节点</span><br><span class="line">&lt;!ELEMENT hr (employee?)&gt;</span><br></pre></td></tr></table></figure><h3 id="XML引用DTD文件">XML引用DTD文件</h3><p>在XML中使用&lt;!DOCTYPE&gt;标签来引用DTD文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">书写格式</span><br><span class="line">&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt;</span><br><span class="line">示例:</span><br><span class="line">&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="XML-Schema">XML Schema</h3><blockquote><p>XML Schema比DTD更为复杂，提供了更多功能</p><p>XML Schema提供了数据类型，格式限定，数据范围等特性</p><p>XML Schema是W3C标准</p></blockquote><p>.xsd文件</p><h3 id="DOM文档对象模型">DOM文档对象模型</h3><blockquote><p>DOM(Document Object Model)定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构查看，能够通过DOM树来读写所有元素</p></blockquote><h3 id="Dom4j">Dom4j</h3><blockquote><p>Dom4j是一个易用的，开源的库，用于解析XML，它应用于Java平台，具有性能优异，功能强大和极易使用的特点</p><p>Dom4j将XML视为Document对象</p><p>XML标签被Dom4j定义为Element对象</p></blockquote><p>下面的代码通过Dom4j对XML的节点值与属性进行了打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dom4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HrReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readXml</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String file = <span class="string">&quot;D:/javase/untitled/src/hr.xml&quot;</span>;</span><br><span class="line">        <span class="comment">//SAXReader是读取XML文件的核心类，用于将XML解析后以&quot;树&quot;的形式保存在内存中</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Document document = reader.read(file);</span><br><span class="line">            <span class="comment">//获取XML文档的根节点，返回一个Element对象</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            List&lt;Element&gt; employees = root.elements(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element employee:employees)&#123;</span><br><span class="line">                <span class="comment">//element方法用于获取唯一的子节点对象</span></span><br><span class="line">                Element name = employee.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="comment">//getText方法用于获取标签文本</span></span><br><span class="line">                String empName = name.getText();</span><br><span class="line">                System.out.println(empName);</span><br><span class="line">                <span class="comment">//elementText方法用于获取子标签的文本</span></span><br><span class="line">                System.out.println(employee.elementText(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">                <span class="comment">//用于获取节点的属性</span></span><br><span class="line">                Attribute att = employee.attribute(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">                System.out.println(att.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HrReader reader = <span class="keyword">new</span> HrReader();</span><br><span class="line">        reader.readXml();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="利用Dom4j更新XML">利用Dom4j更新XML</h3><p>idea里格式化代码快捷键</p><blockquote><p>ctrl+shift+L</p></blockquote><p>下面这段代码利用Dom4j对XML文件进行了写入操作</p><h3 id="XPath路径表达式">XPath路径表达式</h3><blockquote><p>XPath路径表达式是XML文档中查找数据的语言</p><p>掌握XPath可以极大的提高在提起数据时的开发效率</p><p>学习XPath本质就是掌握各种形式表达式的技巧</p></blockquote><h3 id="XPath基本表达式">XPath基本表达式</h3><p>最基本表达式</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从根节点选取</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑他们的位置</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>…</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><h3 id="XPath基本表达式案例">XPath基本表达式案例</h3><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>bookstore</td><td>选取bookstore元素的所有子节点</td></tr><tr><td>/bookstore</td><td>选取根元素bookstore注释:假如路径起始于正斜杠(/),则此路径始终代表到某元素的绝对路径</td></tr><tr><td>bookstore/book</td><td>选取属于bookstore的子元素的所有book元素</td></tr><tr><td>//book</td><td>选取所有book子元素，而不管它们在文档中的位置</td></tr><tr><td>bookstore//book</td><td>选择属于bookstore元素的后代的所有book元素，而不管他们位于bookstore之下的什么位置</td></tr><tr><td>//@lang</td><td>选取名为lang的所有属性</td></tr></tbody></table><h3 id="XPath谓语表达式">XPath谓语表达式</h3><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取属于bookstore子元素的第一个book元素</td></tr><tr><td>/bookstore/book[last()]</td><td>选取属于bookstore子元素的最后一个book元素</td></tr><tr><td>/bookstore/book[last()-1]</td><td>选取属于bookstore子元素的倒数第二个book元素</td></tr><tr><td>/bookstore/book[position()&lt;3]</td><td>选取最前面的两个属于bookstore元素的子元素的book元素</td></tr><tr><td>//title[@lang]</td><td>选取所有拥有名为lang的属性的title元素</td></tr><tr><td>//title[@lang=‘eng’]</td><td>选取所有title元素，且这些元素拥有值为eng的lang属性</td></tr><tr><td>/bookstore/book[price&gt;35.00]</td><td>选取bookstore元素的所有book元素，且其中的price元素的值需大于35.00</td></tr><tr><td>/bookstore/book[price&gt;35.00]/title</td><td>选取bookstore元素中的book元素的所有title元素，且其中的price元素需大于35.00</td></tr></tbody></table><h3 id="Jaxen介绍">Jaxen介绍</h3><ol><li>Jaxen是一个Java编写的开源的XPath库。这是适应多种不同的对象模型，包括DOM，XOM，dom4j和JDOM。</li><li>Dom4j底层依赖Jaxen实现XPath查询</li><li>Jaxen下载地址:jaxen.codehaus.org</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dom4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Node;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPathTestor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XPath</span><span class="params">(String xpathExp)</span></span>&#123;</span><br><span class="line">        String file = <span class="string">&quot;D:/javase/untitled/src/hr.xml&quot;</span>;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Document doc = reader.read(file);</span><br><span class="line">            List&lt;Node&gt; nodes = doc.selectNodes(xpathExp);</span><br><span class="line">            <span class="keyword">for</span>(Node node:nodes)&#123;</span><br><span class="line">                Element emp = (Element)node;</span><br><span class="line">                System.out.println(emp.attributeValue(<span class="string">&quot;no&quot;</span>));</span><br><span class="line">                System.out.println(emp.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                System.out.println(emp.elementText(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">                System.out.println(emp.elementText(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XPathTestor xPathTestor = <span class="keyword">new</span> XPathTestor();</span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;/hr/employee&quot;);</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee&quot;);</span></span><br><span class="line">        <span class="comment">//查询工资小于4000的员工信息</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[salary&lt;4000]&quot;);</span></span><br><span class="line">        <span class="comment">//查询李铁柱的信息</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[name=&#x27;李铁柱&#x27;]&quot;);</span></span><br><span class="line">        <span class="comment">//利用属性筛选</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[@no=8105]&quot;);</span></span><br><span class="line">        <span class="comment">//编号比较小的节点</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[1]&quot;);</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[last()]&quot;);</span></span><br><span class="line"><span class="comment">//        获取前两名</span></span><br><span class="line">        xPathTestor.XPath(<span class="string">&quot;//employee[position()&lt;3]&quot;</span>);</span><br><span class="line"><span class="comment">//        获取第一和第二</span></span><br><span class="line">        xPathTestor.XPath(<span class="string">&quot;//employee[1]|//employee[2]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;XML的用途&quot;&gt;XML的用途&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Java程序的配置描述文件&lt;/p&gt;
&lt;p&gt;2.用于保存程序的产生的数据&lt;/p&gt;
&lt;p&gt;3.网络间的数据传输&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;XML的文档结构&quot;&gt;XML的</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发基础</title>
    <link href="http://example.com/2022/01/07/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/01/07/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-07T08:10:47.000Z</published>
    <updated>2022-01-11T07:42:36.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是线程和进程">什么是线程和进程</h3><p><strong>进程是程序的一次执行过程</strong>，<strong>是系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是线程和进程&quot;&gt;什么是线程和进程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;进程是程序的一次执行过程&lt;/strong&gt;，&lt;strong&gt;是系统运行程序的基本单位&lt;/strong&gt;，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，</summary>
      
    
    
    
    <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>DML-数据库定义语言</title>
    <link href="http://example.com/2022/01/07/DML-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2022/01/07/DML-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</id>
    <published>2022-01-07T07:10:10.000Z</published>
    <updated>2022-01-09T09:30:37.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库操作语言">数据库操作语言</h3><p>添加操作:insert into…</p><h4 id="添加一条记录">添加一条记录</h4><p>a.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名，字段名，....) <span class="keyword">values</span> (数据<span class="number">1</span>，数据<span class="number">2</span>，...)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (name，age) <span class="keyword">values</span> (‘TOM’，<span class="number">18</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (name) <span class="keyword">values</span> (<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><p>b.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (数据<span class="number">1</span>,数据<span class="number">2</span>,数据...);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span> (&quot;rose&quot;)</span><br></pre></td></tr></table></figure><p><strong>注意:用方法b有多少个字段，就给多少个值</strong></p><p>设置字段编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 字段名 gbk;</span><br></pre></td></tr></table></figure><h4 id="添加多条记录">添加多条记录</h4><p>a.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段名,字段名,....) <span class="keyword">values</span> (数据<span class="number">1</span>,数据<span class="number">2</span>,...),(数据<span class="number">1</span>,数据<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><h4 id="date-datetime-timestamp">date,datetime,timestamp</h4><h4 id="修改操作">修改操作</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库操作语言&quot;&gt;数据库操作语言&lt;/h3&gt;
&lt;p&gt;添加操作:	insert into…&lt;/p&gt;
&lt;h4 id=&quot;添加一条记录&quot;&gt;添加一条记录&lt;/h4&gt;
&lt;p&gt;a.&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>K个一组反转链表</title>
    <link href="http://example.com/2022/01/07/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/07/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-07T04:24:03.000Z</published>
    <updated>2022-01-07T04:28:54.946Z</updated>
    
    <content type="html"><![CDATA[<h3 id="K个一组反转链表">K个一组反转链表</h3><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果链表为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode a = head;ListNode b = head;</span><br><span class="line">        <span class="comment">//搜寻节点b的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">if</span>(b==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">            b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反转了a到b的节点</span></span><br><span class="line">        ListNode HeadNode = reverse(a,b);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        a.next = reverseKGroup(b,k);</span><br><span class="line">        <span class="keyword">return</span> HeadNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表从a到b的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode a,ListNode b)</span></span>&#123;</span><br><span class="line">        ListNode pre = a;ListNode cur = a;</span><br><span class="line">        ListNode sub = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=b)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur.next = sub;</span><br><span class="line">            sub = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sub.val);</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;K个一组反转链表&quot;&gt;K个一组反转链表&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。&lt;/p&gt;
&lt;p&gt;如果节点总数不是 k 的整数倍，那么请将最</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>GET请求和POST请求</title>
    <link href="http://example.com/2022/01/06/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82/"/>
    <id>http://example.com/2022/01/06/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82/</id>
    <published>2022-01-06T14:26:24.000Z</published>
    <updated>2022-01-06T15:19:21.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义">定义</h3><p>无论是<strong>GET</strong>还是<strong>POST</strong>，统一由视图函数接收请求，通过判断<strong>request.method</strong>区分具体的请求动作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if request.method == &#x27;GET&#x27;:</span><br><span class="line">处理GET请求时的业务逻辑</span><br><span class="line">elif request.method == &#x27;POST&#x27;:</span><br><span class="line">处理POST请求时的业务逻辑</span><br><span class="line">else:</span><br><span class="line">其他请求业务逻辑</span><br></pre></td></tr></table></figure><h3 id="GET请求">GET请求</h3><p><strong>GET</strong>请求动作，一般用于向服务器获取数据</p><p>能够产生<strong>GET</strong>请求的场景</p><p>​-浏览器地址栏输入URL，回车后</p><p>​-<a href="地址?参数=值&参数=值"></p><p>​-form表单中的method为GET</p><p><strong>GET</strong>请求方式中，如果有数据需要传给服务器，通常会用查询字符串(Query String)传递[不要传递敏感数据]</p><p>URL格式:xxx?参数1:值1&amp;参数2:值2</p><p>​-如:<a href="http://127.0.0.1/page1?a=100&amp;b=200">http://127.0.0.1/page1?a=100&amp;b=200</a></p><p>服务器端接收数据</p><p>​获取客户端请求GET请求提交的数据</p><h4 id="方法实例">方法实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.GET[<span class="string">&#x27;参数名&#x27;</span>]</span><br><span class="line">request.GET(<span class="string">&#x27;参数名&#x27;</span>,<span class="string">&#x27;默认值&#x27;</span>)</span><br><span class="line">request.GET.getlist(<span class="string">&#x27;参数名&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;无论是&lt;strong&gt;GET&lt;/strong&gt;还是&lt;strong&gt;POST&lt;/strong&gt;，统一由视图函数接收请求，通过判断&lt;strong&gt;request.method&lt;/strong&gt;区分具体的请求动作&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    <category term="django学习" scheme="http://example.com/categories/django%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>DDL-数据库定义语言</title>
    <link href="http://example.com/2022/01/06/DDL-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2022/01/06/DDL-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</id>
    <published>2022-01-06T10:08:05.000Z</published>
    <updated>2022-01-07T07:07:29.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看有哪些数据库">查看有哪些数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><h3 id="创建一个新的数据库">创建一个新的数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="查看数据库创建细节">查看数据库创建细节</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="删除数据库">删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="使用数据库名字">使用数据库名字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="查看数据库的表">查看数据库的表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><h3 id="创建一张新的表">创建一张新的表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名变量类型,</span><br><span class="line">字段名变量类型,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="常见数据类型">常见数据类型</h3><p>int</p><p>decimal(5,2)-5是精度，小数点后面2位</p><p>date</p><p>datatime</p><p>timestamp</p><p>varchar(20)</p><h3 id="查看表的结构">查看表的结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名</span><br></pre></td></tr></table></figure><h3 id="在原有的基础之上增加一个新的字段">在原有的基础之上增加一个新的字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段名 数据类型;</span><br></pre></td></tr></table></figure><h3 id="在原有的基础之上修改字段的名字">在原有的基础之上修改字段的名字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 原字段名 新字段名数据类型;</span><br></pre></td></tr></table></figure><h3 id="在原表基础之上，修改字段的数据类型">在原表基础之上，修改字段的数据类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 原字段名 原字段名新的数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 原字段名 新的数据类型;</span><br></pre></td></tr></table></figure><h3 id="删除某一个字段">删除某一个字段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br><span class="line">alter table person drop gender;</span><br></pre></td></tr></table></figure><h3 id="修改表的名字">修改表的名字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">table</span> 原表名 <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure><h3 id="删除指定的表">删除指定的表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;查看有哪些数据库&quot;&gt;查看有哪些数据库&lt;/h3&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL语句介绍</title>
    <link href="http://example.com/2022/01/06/SQL%E8%AF%AD%E5%8F%A5%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/01/06/SQL%E8%AF%AD%E5%8F%A5%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-01-06T09:59:34.000Z</published>
    <updated>2022-01-06T10:07:46.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL介绍">SQL介绍</h3><table><thead><tr><th>DDL</th><th>数据库定义语言，这里边的SQL语言，主要用于操作数据库和表的结构</th></tr></thead><tbody><tr><td>DML</td><td>数据库定义语言，这里边的SQL语言，主要用于操作数据库的表的数据的增删改查</td></tr><tr><td>DQL</td><td>数据库定义语言，这里边的SQL语言，主要用于操作数据库的表的数据的查询</td></tr><tr><td>DCL</td><td>数据库定义语言，这里边的SQL语言，主要用于操作数据库的用户的账号密码，权限和访问级别的</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL介绍&quot;&gt;SQL介绍&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DDL&lt;/th&gt;
&lt;th&gt;数据库定义语言，这里边的SQL语言，主要用于操作数据库和表的结构&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DML&lt;/t</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL服务启动</title>
    <link href="http://example.com/2022/01/06/MySQL%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2022/01/06/MySQL%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/</id>
    <published>2022-01-06T09:46:34.000Z</published>
    <updated>2022-01-06T10:00:17.344Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qqwangfan/article/details/90905642">MySQL服务的启动</a></p><p>在DOS下输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开启MySQL</span><br><span class="line">$net start MySQL80(服务名)</span><br><span class="line">关闭MySQL</span><br><span class="line">$net stop MySQL80(服务名)</span><br></pre></td></tr></table></figure><h3 id="MySQL的登录与退出">MySQL的登录与退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mysql -u root -p</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qqwangfan/article/details/90905642&quot;&gt;MySQL服务的启动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在DOS下输入&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
</feed>
