<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>THYLOVEZJ的博客</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-01-11T11:41:25.309Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>THYLOVEZJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JSP与Servlet进阶</title>
    <link href="http://example.com/2022/01/11/JSP%E4%B8%8EServlet%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2022/01/11/JSP%E4%B8%8EServlet%E8%BF%9B%E9%98%B6/</id>
    <published>2022-01-11T09:30:12.000Z</published>
    <updated>2022-01-11T11:41:25.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="利用请求头开发多端应用">利用请求头开发多端应用</h3><p>下面的代码模拟了利用请求头的不同识别不同的主机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovezj.www;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet(&quot;/au&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAgentServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String userAgent = request.getHeader(<span class="string">&quot;User-Agent&quot;</span>);</span><br><span class="line">        <span class="comment">//设置中文显示</span></span><br><span class="line">        response.setContentType(<span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line">        String output = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(userAgent.indexOf(<span class="string">&quot;Windows&quot;</span>) != -<span class="number">1</span>)&#123;</span><br><span class="line">            output = <span class="string">&quot;&lt;h1&gt;这是PC端首页&lt;/h1&gt;&quot;</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (userAgent.indexOf(<span class="string">&quot;iPhone&quot;</span>)!=-<span class="number">1</span>||userAgent.indexOf(<span class="string">&quot;Android&quot;</span>)!=-<span class="number">1</span>)&#123;</span><br><span class="line">            output = <span class="string">&quot;&lt;h1&gt;这是移动端首页&lt;/h1&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        response.getWriter().println(output);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="响应的结构">响应的结构</h3><p>HTTP响应包含三个部分:响应行，响应头，响应体</p><table><thead><tr><th>状态码</th><th>错误描述</th></tr></thead><tbody><tr><td>200</td><td>服务器处理成功</td></tr><tr><td>404</td><td>无法找到文件</td></tr><tr><td>500</td><td>内部服务器错误</td></tr><tr><td>403</td><td>服务器拒绝访问</td></tr><tr><td>301，302</td><td>请求重定向</td></tr><tr><td>400</td><td>无效的请求</td></tr><tr><td>401</td><td>未经过授权</td></tr><tr><td>503</td><td>服务器超负载或正停机维护，无法处理请求</td></tr></tbody></table><h3 id="ContentType的作用">ContentType的作用</h3><table><thead><tr><th>MIME类型</th><th>描述</th></tr></thead><tbody><tr><td>text/plain</td><td>纯文本</td></tr><tr><td>text/html</td><td>HTML文档</td></tr><tr><td>text/xml</td><td>XML文档</td></tr><tr><td>application/x-msdownload</td><td>需要下载的资源</td></tr><tr><td>image/jpeg    image/gif   …</td><td>图片资源</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;利用请求头开发多端应用&quot;&gt;利用请求头开发多端应用&lt;/h3&gt;
&lt;p&gt;下面的代码模拟了利用请求头的不同识别不同的主机&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>Servlet与JSP进阶</title>
    <link href="http://example.com/2022/01/11/Servlet%E4%B8%8EJSP%E8%BF%9B%E9%98%B6/"/>
    <id>http://example.com/2022/01/11/Servlet%E4%B8%8EJSP%E8%BF%9B%E9%98%B6/</id>
    <published>2022-01-11T09:29:18.000Z</published>
    <updated>2022-01-11T09:29:18.974Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>JSP入门</title>
    <link href="http://example.com/2022/01/11/JSP%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/11/JSP%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-11T07:41:58.000Z</published>
    <updated>2022-01-11T09:28:35.455Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Servlet开发的痛点">Servlet开发的痛点</h3><p>静态的HTML与动态Java代码混合在一起，难以维护</p><p>Servlet利用out.println()语句输出，开发效率低下</p><p>Eclipse很难在开发过程中发现错误，调试困难</p><h3 id="JSP介绍">JSP介绍</h3><p>JSP全称是(Java Server Pages),Java服务器页面</p><p>JSP是J2EE的功能模块，由Web服务器执行</p><p>JSP的作用就是降低动态网页开发难度</p><h3 id="JSP的特点">JSP的特点</h3><p>JSP使用简单，短时间学习便可上手使用</p><p>JSP可将Java代码与HTML分离，降低开发难度</p><p>JSP的本质就是Servlet</p><h3 id="JSP的运行要求">JSP的运行要求</h3><p>可正常的Tomcat</p><p>所有JSP页面扩展名必须是.jsp</p><p>JSP页面应该放在Web应用程序目录下</p><h3 id="第一段JSP代码">第一段JSP代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">  Created by IntelliJ IDEA.</span><br><span class="line">  User: THY</span><br><span class="line">  Date: <span class="number">2022</span>/<span class="number">1</span>/<span class="number">11</span></span><br><span class="line">  Time: <span class="number">16</span>:<span class="number">00</span></span><br><span class="line">  To change <span class="keyword">this</span> template use File | Settings | File Templates.</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%@ page contentType=<span class="string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="string">&quot;java&quot;</span> %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang=<span class="string">&quot;en&quot;</span>&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=<span class="string">&quot;UTF-8&quot;</span>&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;th&gt;year&lt;/th&gt;</span><br><span class="line">        &lt;th&gt;salary&lt;/th&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=<span class="number">50</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> salary = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (i&lt;=<span class="number">5</span>)&#123;</span><br><span class="line">                salary = <span class="number">1500</span>+i*<span class="number">150</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">5</span> &amp;&amp; i&lt;=<span class="number">10</span>)&#123;</span><br><span class="line">                salary = <span class="number">1500</span>+<span class="number">150</span>*<span class="number">5</span>+<span class="number">300</span>*(i-<span class="number">5</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(i&gt;<span class="number">10</span>)&#123;</span><br><span class="line">                salary = <span class="number">1500</span>+<span class="number">150</span>*<span class="number">5</span>+<span class="number">300</span>*<span class="number">5</span>+<span class="number">375</span>*(i-<span class="number">10</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;td&gt;&quot;</span>+ i +<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;td&gt;&quot;</span>+ salary +<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">            out.println(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    %&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="JSP执行过程">JSP执行过程</h3><p>浏览器给Tomcat发请求-&gt;Tomcat将JSP转译为Servlet源代码-&gt;Java对其进行编译生成Servlet字节码</p><h3 id="JSP基本语法">JSP基本语法</h3><p>JSP语法十分简单，按功能可分为以下几种</p><p>1.JSP代码块</p><p>2.JSP声明构造块</p><p>3.JSP输出指令</p><p>4.JSP处理指令</p><p>JSP代码块用于在JSP中嵌入Java代码</p><p>JSP代码语法块:&lt;% java代码 %&gt;</p><p>JSP声明构造块用于声明变量或者方法</p><p>JSP声明构造块语法:&lt;%!声明语句%&gt;</p><p>例如:&lt;%!public int add(int a,int b){return a+b;}%&gt;</p><p>JSP输出指令</p><p>JSP输出指令用于在JSP页面中显示java代码执行结果</p><p>JSP输出指令语法:&lt;%=java代码%&gt;</p><p>例如:&lt;%=“&lt; b &gt;”+name+“&lt; /b &gt;”%&gt;</p><p>JSP处理指令</p><p>JSP处理指令用于提供JSP执行过程中的辅助信息</p><p>JSP处理指令语法:&lt; %@jsp指令% &gt;</p><p>例如:&lt;%@ page import=“java.util.*” %&gt;</p><h3 id="JSP常用处理指令">JSP常用处理指令</h3><p>&lt;%@ page %&gt;定义当前JSP页面全局设置</p><p>&lt;%@ include %&gt;将其他JSP页面与当前JSP页面合并</p><p>&lt;%@ taglib %&gt;引入JSP标签库</p><h3 id="JSP中注释的区别">JSP中注释的区别</h3><p>&lt;%-- 注释 --%&gt;JSP注释，被注释语句不做任何处理</p><p>// , /* … */用于注释&lt;%%&gt;java代码，被注释代码不执行</p><!-- html -->HTML注释，被注释的语句不会被浏览器解释<h3 id="JSP页面重用">JSP页面重用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@include file=&quot;include/header.jsp&quot;%&gt;&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Servlet开发的痛点&quot;&gt;Servlet开发的痛点&lt;/h3&gt;
&lt;p&gt;静态的HTML与动态Java代码混合在一起，难以维护&lt;/p&gt;
&lt;p&gt;Servlet利用out.println()语句输出，开发效率低下&lt;/p&gt;
&lt;p&gt;Eclipse很难在开发过程中发现错误，调试</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="http://example.com/2022/01/11/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <id>http://example.com/2022/01/11/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</id>
    <published>2022-01-11T04:56:33.000Z</published>
    <updated>2022-01-11T06:47:55.616Z</updated>
    
    <content type="html"><![CDATA[<h3 id="验证二叉搜索树">验证二叉搜索树</h3><blockquote><p>给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。</p><p>有效 二叉搜索树定义如下：</p><p>节点的左子树只包含 小于 当前节点的数。<br>节点的右子树只包含 大于 当前节点的数。<br>所有左子树和右子树自身必须也是二叉搜索树。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [2,1,3]</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure></blockquote><p>思路:</p><p>​验证一个二叉树是BST，即要求二叉树的左子树比二叉树的根节点值小，二叉树的右子树比根节点值大。那么我们可以写出如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="comment">//注意，当只有一个节点时，肯定为二叉搜索树，所以直接返回true</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.left!=<span class="keyword">null</span>&amp;&amp;root.val&lt;=root.left.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.right!=<span class="keyword">null</span>&amp;&amp;root.val&gt;=root.right.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        isValidBST(root.left);</span><br><span class="line">        isValidBST(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样的代码是存在漏洞的，比如当此时，该二叉树少了根节点的约束。</p><p><img src="D:%5Cthy123%5Csource%5Cimg%5C5.png" alt=""></p><p>因此，我们需要添加根节点的约束，代码如下。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> isValidBST(root,<span class="keyword">null</span>,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root,TreeNode min,TreeNode max)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(min!=<span class="keyword">null</span>&amp;&amp;root.val&lt;=min.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(max!=<span class="keyword">null</span>&amp;&amp;root.val&gt;=max.val)<span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> isValidBST(root.left,min,root)&amp;&amp;isValidBST(root.right,root,max);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在BST中搜索一个数">在BST中搜索一个数</h3><blockquote><p>给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">给定二叉搜索树:</span><br><span class="line"></span><br><span class="line">        4</span><br><span class="line">       / \</span><br><span class="line">      2   7</span><br><span class="line">     / \</span><br><span class="line">    1   3</span><br><span class="line"></span><br><span class="line">和值: 2</span><br></pre></td></tr></table></figure></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  2     </span><br><span class="line"> / \   </span><br><span class="line">1   3</span><br></pre></td></tr></table></figure></blockquote><p>本题虽然不难，但是需要注意一些细节</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">searchBST</span><span class="params">(TreeNode root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span>(root.val==val)<span class="keyword">return</span> root;</span><br><span class="line">        <span class="comment">//由于是BST我们可以加上一些判断条件，使其寻找正确的子树</span></span><br><span class="line">        <span class="comment">//当val小于根节点的值时，我们应该遍历左子树去寻找val，当val大于根节点的值时，我们应该遍历右子树去寻找val</span></span><br><span class="line">        <span class="keyword">if</span>(val&lt;root.val)<span class="keyword">return</span> searchBST(root.left,val);</span><br><span class="line">        <span class="comment">//这里需要注意，不能写为两个if，否则编译器会报错。</span></span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> searchBST(root.right,val);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有本题需要注意，我们如何返回一个子树，即给递归加上return。</p><h3 id=""></h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;验证二叉搜索树&quot;&gt;验证二叉搜索树&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;有效 二叉搜索树定义如下：&lt;/p&gt;
&lt;p&gt;节点的左子树只包含 小于 当前节点的数。&lt;br&gt;
节点的右子</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>把二叉搜索树转换为累加树</title>
    <link href="http://example.com/2022/01/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/"/>
    <id>http://example.com/2022/01/10/%E6%8A%8A%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%B4%AF%E5%8A%A0%E6%A0%91/</id>
    <published>2022-01-10T04:08:48.000Z</published>
    <updated>2022-01-10T04:08:48.658Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>二叉搜索树中第K小的元素</title>
    <link href="http://example.com/2022/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://example.com/2022/01/10/%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%AC%ACK%E5%B0%8F%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2022-01-10T03:43:14.000Z</published>
    <updated>2022-01-10T03:54:03.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="二叉搜索树中第K小的元素">二叉搜索树中第K小的元素</h3><blockquote><p>给定一个二叉搜索树的根节点 <code>root</code> ，和一个整数 <code>k</code> ，请你设计一个算法查找其中第 <code>k</code> 个最小元素（从 1 开始计数）。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [3,1,4,null,2], k = 1</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure></blockquote><p><strong>二叉搜索树的中序遍历是有顺序的二叉树</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"> <span class="keyword">int</span> key=<span class="number">0</span>;</span><br><span class="line"> <span class="keyword">int</span> ans=<span class="number">0</span>;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(TreeNode root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        traverse(root,k);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode root,<span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.left,k);</span><br><span class="line">        key++;</span><br><span class="line">        <span class="keyword">if</span>(key == k)&#123;</span><br><span class="line">            ans = root.val;</span><br><span class="line">        &#125;</span><br><span class="line">        traverse(root.right,k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;二叉搜索树中第K小的元素&quot;&gt;二叉搜索树中第K小的元素&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个二叉搜索树的根节点 &lt;code&gt;root&lt;/code&gt; ，和一个整数 &lt;code&gt;k&lt;/code&gt; ，请你设计一个算法查找其中第 &lt;code&gt;k&lt;/code&gt; </summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>Servlet入门</title>
    <link href="http://example.com/2022/01/09/Servlet%E5%85%A5%E9%97%A8/"/>
    <id>http://example.com/2022/01/09/Servlet%E5%85%A5%E9%97%A8/</id>
    <published>2022-01-09T13:41:51.000Z</published>
    <updated>2022-01-11T10:17:19.233Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是CS架构-Client-server">什么是CS架构(Client-server)</h3><p>Client/Sever结构(C/S结构)是指客户端和服务器结构</p><p>优点:数据方便共享，安全性高</p><p>缺点:必须安装客户端，升级与维护困难</p><h3 id="互联网时代-Browser-Server模式">互联网时代(Browser-Server模式)</h3><p>Browser-Server(B/S)模式即浏览器和服务器架构模式</p><p>优点:开发简单，无需安装客户端，数据易于共享</p><p>缺点:相较于C/S模式，执行速度与用户体验相对较弱。</p><h3 id="B-S模式执行流程">B/S模式执行流程</h3><p>用户输入baidu.com-&gt;浏览器根据输入的域名解析成IP地址(DNS协议)-&gt;WEB服务器&lt;-&gt;服务器程序</p><h3 id="请求与响应">请求与响应</h3><p>从浏览器发送给服务器的数据包称为请求Request</p><p>从服务器返回给浏览器的结果称为响应response</p><h3 id="J2EE是什么">J2EE是什么</h3><p>J2EE是指Java2企业版</p><p>开发BS(Web)应用程序就是J2EE最核心的功能</p><p>J2EE由13个功能模块组成</p><table><thead><tr><th>模块</th><th>功能</th></tr></thead><tbody><tr><td>Servlet</td><td>Web服务器小程序</td></tr><tr><td>JSP</td><td>服务器页面</td></tr><tr><td>JDBC</td><td>数据库交互模块</td></tr><tr><td>XML</td><td>XML交互模块</td></tr><tr><td>EJB</td><td>企业级Java Bean</td></tr><tr><td>RMI</td><td>远程调用</td></tr><tr><td>JNDI</td><td>目录服务</td></tr><tr><td>JMS</td><td>消息服务</td></tr><tr><td>JTA</td><td>事务管理</td></tr><tr><td>JavaMail</td><td>发送/接收Email</td></tr><tr><td>JAF</td><td>安全框架</td></tr><tr><td>CORBA</td><td>CORBA集成</td></tr><tr><td>JTS</td><td>CORBA事务监控</td></tr></tbody></table><h3 id="Apache-Tomcat">Apache Tomcat</h3><p>Tomcat是Apache软件基金会下一款免费的开放源代码的Web应用服务器程序</p><h3 id="J2EE和Tomcat的关系">J2EE和Tomcat的关系</h3><p>J2EE是一组技术规范与指南，具体实现由软件厂商决定</p><p>Tomcat是J2EE Web(servlet与JSP)标准的实现者</p><p>J2SE是J2EE运行的基石，运行Tomcat离不开J2SE</p><h3 id="Servlet">Servlet</h3><p>Servlet(Servlet Applet)服务器小程序，主要用于生成Web内容</p><p>Servlet是J2EE最重要的组成部分，也是我们学习的重点</p><h3 id="Tomcat的安装与运行">Tomcat的安装与运行</h3><p>Tomcat下载去Tomcat官网下载，版本要根据JDK版本确定，如果JDK为8，那么就需要采用Tomcat8的版本</p><p>安装下来以后，需要配置JDK的环境变量JAVA_HOME</p><p>然后在命令行进入Tomcat的bin目录下输入startup.bat，然后访问localhost:8080，如果能出现Tomcat的官网，则说明配置完成</p><h3 id="Tomcat日志乱码">Tomcat日志乱码</h3><p>参考博客</p><p><a href="https://blog.csdn.net/peanut_trees/article/details/106716045">解决乱码</a></p><h3 id="发现8080端口被占怎么办">发现8080端口被占怎么办</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//查询8080端口进程pid</span><br><span class="line">netstat -ano|findstr 8080</span><br></pre></td></tr></table></figure><h3 id="第一个Servlet程序">第一个Servlet程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovexj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="comment">//HttpServlet是所有小程序的父类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="comment">//该方法里由两个参数，第一个参数是Http请求，第二个是Http响应</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">//接收请求发来的参数</span></span><br><span class="line">        String name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String html = <span class="string">&quot;&lt;h1&gt;&quot;</span>+name+<span class="string">&quot;&lt;/h1&gt;&quot;</span>;</span><br><span class="line">        PrintWriter out = resp.getWriter();</span><br><span class="line">        out.println(html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>XML需要进行配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>first<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.thylovexj.FirstServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--这里视频上有误，新版的不用加文件名，直接使用url-pattern就OK了，同时记得每次修改完了要重新上传--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>first<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hi<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置完后，启动Tomcat服务器即可在<a href="">localhost:8080/hi</a>访问第一个servlet程序</p><h3 id="标准的Java-Web工程结构">标准的Java Web工程结构</h3><table><thead><tr><th>组织结构</th><th>描述</th></tr></thead><tbody><tr><td>tomcat安装目录/webapps</td><td>Tomcat应用根目录</td></tr><tr><td>/web应用目录/</td><td>Java Web应用目录</td></tr><tr><td>/web应用目录/index.html|.jsp</td><td>默认首页</td></tr><tr><td>/WEB-INF</td><td>WEB应用的安全目录，用来存放配置文件</td></tr><tr><td>/WEB-INF/web.xml</td><td>web.xml是&quot;部署描述符文件&quot;，是该Web项目的核心文件</td></tr><tr><td>/WEB-INF/classes</td><td>存放编译后的classes文件</td></tr><tr><td>/WEB-INF/lib</td><td>用于存放WEB应用依赖的jar文件</td></tr><tr><td>/META-INF/MANIFEST.MF</td><td>包含Web应用的版本信息</td></tr></tbody></table><h3 id="Servlet开发步骤">Servlet开发步骤</h3><blockquote><p>创建Servlet类，集成HttpServlet</p><p>重写service方法，编写程序代码</p><p>配置web.xml，绑定URL</p></blockquote><h3 id="请求参数">请求参数</h3><blockquote><p>请求参数是指浏览器通过请求向Tomcat提交的数据</p><p>请求参数通常是用户输入的数据，待Servlet进行处理</p><p>参数名1=值1&amp;参数名2=值2&amp;参数名3=值3</p></blockquote><h3 id="Servlet接收请求参数">Servlet接收请求参数</h3><p>前端通过form标签里的属性里的action=“URL”将数据提交给后端</p><p>URL是servlet绑定的地址</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接收单个参数</span></span><br><span class="line">request.getParameter();</span><br><span class="line"><span class="comment">//接收多个同名参数</span></span><br><span class="line">request.getParameterValues();</span><br></pre></td></tr></table></figure><p>下面的代码展示了html提交的数据，在浏览器上显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>学员信息登记表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://localhost:8080/servletTest_war_exploded/sample&quot;</span>&gt;</span></span><br><span class="line">    姓名:<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    电话<span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;mobile&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    特长</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;English&quot;</span>&gt;</span>英语</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Math&quot;</span>&gt;</span>数学</span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;spec&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Chinese&quot;</span>&gt;</span>语文</span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.thylovexj;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        PrintWriter writer = resp.getWriter();</span><br><span class="line">        String name = req.getParameter(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        String mobile = req.getParameter(<span class="string">&quot;mobile&quot;</span>);</span><br><span class="line">        String[] specs = req.getParameterValues(<span class="string">&quot;spec&quot;</span>);</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;h1&gt;name:&quot;</span>+name+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        writer.println(<span class="string">&quot;&lt;h1&gt;mobile:&quot;</span>+mobile+<span class="string">&quot;&lt;/h1&gt;&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (String spe:specs)&#123;</span><br><span class="line">            writer.println(spe);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Get与Post请求方法">Get与Post请求方法</h3><p>Get方式是将数据通过在URL附加数据显性向服务器发送数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/FirServlet/sample?name=zhangsan</span><br></pre></td></tr></table></figure><p>Post方式会将数据存放在“请求体”中隐性向服务器发送数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://localhost:8080/FirstServlet/sample</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">请求体:name=zhangsan</span><br></pre></td></tr></table></figure><p>默认我们提交表单是使用<strong>Get</strong>方法提交，而如果我们要改变方法，可以利用html表单里<strong>method()方法</strong>的<strong>Post</strong>属性提交表单</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doPost()方法只处理Post请求</span><br><span class="line">doGet()方法只处理Get请求</span><br></pre></td></tr></table></figure><h3 id="Get方法和Post方法应用场景">Get方法和Post方法应用场景</h3><blockquote><p>Get常用于不包含敏感信息的查询功能</p></blockquote><blockquote><p>Post用于安全性要求较高的功能或者服务器的写操作</p></blockquote><p>用户登录</p><p>用户注册</p><p>更新公司账目</p><h3 id="Servlet生命周期">Servlet生命周期</h3><p>装载-web.xml</p><p>创建-构造函数第一次访问servlet</p><p>初始化-init()</p><p>提供服务-service()</p><p>销毁-destroy()</p><p><strong>如果刷新页面，只会提供服务，并不会再次创建Servlet对象。</strong></p><h3 id="使用注解简化配置">使用注解简化配置</h3><p>Servlet3.x之后引入了&quot;注解Annotation&quot;特性</p><p>注解用于简化Web应用程序的配置过程</p><p>Servlet核心注解:@WebServlet</p><h3 id="启动时加载Servlet">启动时加载Servlet</h3><p>web.xml使用&lt; load-on-startup &gt;设置启动时加载</p><p>&lt; load-on-startup &gt;0-9999&lt;/ load-on-startup &gt;</p><p>启动时加载在工作中常用于系统的预处理</p><h3 id="在注解设置启动加载">在注解设置启动加载</h3><p>@WebServlet(urlPattern,loadOnStartup=2)</p><p>必须要设置urlPattern,否则不会加载。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是CS架构-Client-server&quot;&gt;什么是CS架构(Client-server)&lt;/h3&gt;
&lt;p&gt;Client/Sever结构(C/S结构)是指客户端和服务器结构&lt;/p&gt;
&lt;p&gt;优点:数据方便共享，安全性高&lt;/p&gt;
&lt;p&gt;缺点:必须安装客户端，升级与维护</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>寻找重复的子树</title>
    <link href="http://example.com/2022/01/09/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/"/>
    <id>http://example.com/2022/01/09/%E5%AF%BB%E6%89%BE%E9%87%8D%E5%A4%8D%E7%9A%84%E5%AD%90%E6%A0%91/</id>
    <published>2022-01-09T04:50:56.000Z</published>
    <updated>2022-01-09T05:15:04.372Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意<strong>一棵</strong>的根结点即可。</p><p>两棵树重复是指它们具有相同的结构以及相同的结点值。</p></blockquote><p>这道题的思路是:</p><p>首先可以想到我们需要声明一个List用来返回根节点</p><p>其次我们应该想到，我们需要一个函数用来收集不同根节点时的左右子树,即下面所示代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">collect(root);</span><br></pre></td></tr></table></figure><p>那么，这些子树应该使用一个Set集合来收集。当遇到新的子树时，往里添加子树。而子树可以将其序列化为字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br></pre></td></tr></table></figure><p>接下来，我们将对collect函数进行实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">Collect</span><span class="params">(Tree root)</span></span>&#123;</span><br><span class="line">    <span class="comment">//如果根节点为空，则返回&quot;#&quot;</span></span><br><span class="line">    <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String left = Collect(root.left);</span><br><span class="line">    String right = Collect(root.right);</span><br><span class="line">    <span class="comment">//将二叉树序列化为字符串</span></span><br><span class="line">    String subtree = left+<span class="string">&quot;,&quot;</span>+right+<span class="string">&quot;,&quot;</span>+root.val;</span><br><span class="line">    <span class="comment">//查看Set中是否含有subtree，如果没有则添加subtree，如果有则将其根节点添加到list中。</span></span><br><span class="line">    <span class="keyword">if</span>(set.contains(subtree))&#123;</span><br><span class="line">        list.add(root);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        set.add(subtree);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//该函数返回的是root作为根节点时，二叉树的后序遍历。</span></span><br><span class="line">    <span class="keyword">return</span> suntree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这里有个问题，如果有多个子树的根节点的val一样，则会重复添加，我们需要避免这种情况，因此，我们将HashSet改为HashMap记录subtree出现的次数。代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int val, TreeNode left, TreeNode right) &#123;</span></span><br><span class="line"><span class="comment"> *         this.val = val;</span></span><br><span class="line"><span class="comment"> *         this.left = left;</span></span><br><span class="line"><span class="comment"> *         this.right = right;</span></span><br><span class="line"><span class="comment"> *     &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">List&lt;TreeNode&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">HashMap&lt;String,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TreeNode&gt; <span class="title">findDuplicateSubtrees</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        traverse(root);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">traverse</span><span class="params">(TreeNode root)</span></span>&#123;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span>(root==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String left = traverse(root.left);</span><br><span class="line">        String right = traverse(root.right);</span><br><span class="line">        <span class="comment">//后序遍历</span></span><br><span class="line">        String subtree = left+<span class="string">&#x27;,&#x27;</span>+right+<span class="string">&#x27;,&#x27;</span>+root.val;</span><br><span class="line">        <span class="keyword">int</span> fre = map.getOrDefault(subtree,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(fre == <span class="number">1</span>)&#123;</span><br><span class="line">            list.add(root);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(subtree,fre+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//这里的返回，返回的是后序遍历的序列化的二叉树    </span></span><br><span class="line">        <span class="keyword">return</span> subtree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;给定一棵二叉树，返回所有重复的子树。对于同一类的重复子树，你只需要返回其中任意&lt;strong&gt;一棵&lt;/strong&gt;的根结点即可。&lt;/p&gt;
&lt;p&gt;两棵树重复是指它们具有相同的结构以及相同的结点值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这道题的</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>判断回文单链表</title>
    <link href="http://example.com/2022/01/08/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/08/%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E5%8D%95%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-08T12:42:47.000Z</published>
    <updated>2022-01-08T12:55:46.395Z</updated>
    
    <content type="html"><![CDATA[<h3 id="判断回文单链表">判断回文单链表</h3><blockquote><p>给定一个链表的 <strong>头节点</strong> <code>head</code> **，**请判断其是否为回文链表。</p><p>如果一个链表是回文，那么链表节点序列从前往后看和从后往前看是相同的。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: head = [1,2,3,3,2,1]</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure></blockquote><p>思路:刚开始的思路是新建一个链表，然后反转该链表，然后两个指针从前往后遍历，比较每个节点的值。如果相等则返回true，不相等则false。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">ListNode left;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        left = head;</span><br><span class="line">        <span class="keyword">return</span> Palindrome(head);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Palindrome</span><span class="params">(ListNode right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(right == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Boolean res = Palindrome(right.next);</span><br><span class="line">        <span class="comment">//后续遍历</span></span><br><span class="line">        res = res&amp;&amp;(right.val==left.val);</span><br><span class="line">        left = left.next;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;判断回文单链表&quot;&gt;判断回文单链表&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个链表的 &lt;strong&gt;头节点&lt;/strong&gt; &lt;code&gt;head&lt;/code&gt; **，**请判断其是否为回文链表。&lt;/p&gt;
&lt;p&gt;如果一个链表是回文，那么链表节点序列从前往后</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>最长回文子串</title>
    <link href="http://example.com/2022/01/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://example.com/2022/01/08/%E6%9C%80%E9%95%BF%E5%9B%9E%E6%96%87%E4%B8%B2/</id>
    <published>2022-01-08T11:19:39.000Z</published>
    <updated>2022-01-08T11:27:11.481Z</updated>
    
    <content type="html"><![CDATA[<h3 id="最长回文子串">最长回文子串</h3><blockquote><p>给你一个字符串 <code>s</code>，找到 <code>s</code> 中最长的回文子串。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;babad&quot;</span><br><span class="line">输出：&quot;bab&quot;</span><br><span class="line">解释：&quot;aba&quot; 同样是符合题意的答案。</span><br></pre></td></tr></table></figure></blockquote><p>思路:</p><p>1.中心扩散法：定义两个指针，每次向外扩散一个字符，判断两个字符是否相等，直到遍历到最后一个节点或者最前面的节点。这里需要注意，如果该回文串是奇数。那么中间子符为一个，如果为偶数，则中间子符为两个。下面是代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">longestPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        String res = s.substring(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.length();i++)&#123;</span><br><span class="line">            <span class="comment">//找到以i为中心的回文子串</span></span><br><span class="line">            String len1 = Palindrome(s,i,i);</span><br><span class="line">            <span class="comment">//找到以i+1为中心的回文子串</span></span><br><span class="line">            String len2 = Palindrome(s,i,i+<span class="number">1</span>);</span><br><span class="line">            res = res.length()&gt;=len1.length()?res:len1;</span><br><span class="line">            res = res.length()&gt;=len2.length()?res:len2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">Palindrome</span><span class="params">(String s,<span class="keyword">int</span> l,<span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(l&gt;=<span class="number">0</span>&amp;&amp;r&lt;s.length()&amp;&amp;s.charAt(l)==s.charAt(r))&#123;</span><br><span class="line">            l--;r++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substring(l+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;最长回文子串&quot;&gt;最长回文子串&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，找到 &lt;code&gt;s&lt;/code&gt; 中最长的回文子串。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;figure class=</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://example.com/2022/01/07/XML%E7%9A%84%E7%94%A8%E9%80%94/"/>
    <id>http://example.com/2022/01/07/XML%E7%9A%84%E7%94%A8%E9%80%94/</id>
    <published>2022-01-07T14:12:38.000Z</published>
    <updated>2022-01-09T13:39:23.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="XML的用途">XML的用途</h3><blockquote><p>1.Java程序的配置描述文件</p><p>2.用于保存程序的产生的数据</p><p>3.网络间的数据传输</p></blockquote><h3 id="XML的文档结构">XML的文档结构</h3><blockquote><p>1.第一行必须是XML声明</p><p>2.有且只有一个根节点</p><p>3.XML标签的书写规则与HTML相同</p></blockquote><h3 id="XML声明">XML声明</h3><p>XML声明说明XML文档的基本信息，包括版本号与字符集，写在XML第一行。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;encoding=&quot;UTF-8&quot;?&gt;</span></span><br></pre></td></tr></table></figure><p>version代表版本号，UTF-8设置字符集，用于支持中文</p><h3 id="XML标签书写规则">XML标签书写规则</h3><blockquote><p>合法的标签名</p><p>​标签名要有意义</p><p>​建议使用英文，小写字母，单词之间用“-”分隔</p><p>​建议多级标签之间不要存在重名的情况</p><p>适当的注释与缩进</p><p>​适当的注释与缩进可以让XML文档更加容易阅读</p><p>合理使用属性</p><p>​标签属性常用于描述标签不可或缺的信息</p><p>​对标签分组或者为标签设置id时常用属性表示</p><p>特殊子符与CDATA标签</p><p>​标签体中，出现&quot;&lt;“,”&gt;&quot;特殊子符，会破坏文档结构</p><p>​解决办法:使用实体引用</p><p>使用CDATA标签</p><table><thead><tr><th>实体引用</th><th>对应符号</th><th>说明</th></tr></thead><tbody><tr><td>&amp;It ;</td><td>&lt;</td><td>小于</td></tr><tr><td>&amp;gt ;</td><td>&gt;</td><td>大于</td></tr><tr><td>&amp;amp ;</td><td>&amp;</td><td>和号</td></tr><tr><td>&amp;apos ;</td><td>’</td><td>单引号</td></tr><tr><td>&amp;quot ;</td><td>‘’</td><td>双引号</td></tr></tbody></table><p>​CDATA指的是不应由XML解析器进行解析的文本数据</p><p>​从&quot;<![CDATA["开始，到"]]>&quot;结束</p><p>有序的子元素</p></blockquote><h3 id="XML语义约束">XML语义约束</h3><p>XML文档结构正确，但可能不是有效的。</p><p>​例如，员工档案XML中绝不允许出现&quot;植物品种标签&quot;。XML语义约束就是用于规定XML文档中允许出现哪些元素</p><p>XML语义约束有两种定义方式，<strong>DTD</strong>和<strong>XML Schema</strong></p><p><strong>DTD</strong>(Document Type Definition,文档类型定义)是一种简单易用的语义约束方式</p><p><strong>DTD</strong>文件的拓展名为.dtd</p><p>利用<strong>DTD</strong>中的&lt;!ELEMENT&gt;标签，我们可以定义XML文档中允许出现的节点和数量，以hr.xml为例</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义hr节点下只允许出现1个employee子节点</span><br><span class="line">&lt;!ELEMENT hr (employee)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">employee节点下必须包含四个节点，且按顺序出现</span><br><span class="line">&lt;!ELEMENT employee (name,age,salary,department)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">定义name标签体只能是文本，#PCDATA代表文本元素</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br></pre></td></tr></table></figure><p>如某个子节点需要多次重复出现，则需要在子节点后增加响应的描述符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hr节点下最少出现一个employee节点</span><br><span class="line">&lt;!ELEMENT hr (employee+)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hr节点下可出现0...n个employee子节点</span><br><span class="line">&lt;!ELEMENT hr (employee*)&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hr节点下最多出现1个employee子节点</span><br><span class="line">&lt;!ELEMENT hr (employee?)&gt;</span><br></pre></td></tr></table></figure><h3 id="XML引用DTD文件">XML引用DTD文件</h3><p>在XML中使用&lt;!DOCTYPE&gt;标签来引用DTD文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">书写格式</span><br><span class="line">&lt;!DOCTYPE 根节点 SYSTEM &quot;dtd文件路径&quot;&gt;</span><br><span class="line">示例:</span><br><span class="line">&lt;!DOCTYPE hr SYSTEM &quot;hr.dtd&quot;&gt;</span><br></pre></td></tr></table></figure><h3 id="XML-Schema">XML Schema</h3><blockquote><p>XML Schema比DTD更为复杂，提供了更多功能</p><p>XML Schema提供了数据类型，格式限定，数据范围等特性</p><p>XML Schema是W3C标准</p></blockquote><p>.xsd文件</p><h3 id="DOM文档对象模型">DOM文档对象模型</h3><blockquote><p>DOM(Document Object Model)定义了访问和操作XML文档的标准方法，DOM把XML文档作为树结构查看，能够通过DOM树来读写所有元素</p></blockquote><h3 id="Dom4j">Dom4j</h3><blockquote><p>Dom4j是一个易用的，开源的库，用于解析XML，它应用于Java平台，具有性能优异，功能强大和极易使用的特点</p><p>Dom4j将XML视为Document对象</p><p>XML标签被Dom4j定义为Element对象</p></blockquote><p>下面的代码通过Dom4j对XML的节点值与属性进行了打印</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dom4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HrReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">readXml</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String file = <span class="string">&quot;D:/javase/untitled/src/hr.xml&quot;</span>;</span><br><span class="line">        <span class="comment">//SAXReader是读取XML文件的核心类，用于将XML解析后以&quot;树&quot;的形式保存在内存中</span></span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Document document = reader.read(file);</span><br><span class="line">            <span class="comment">//获取XML文档的根节点，返回一个Element对象</span></span><br><span class="line">            Element root = document.getRootElement();</span><br><span class="line">            List&lt;Element&gt; employees = root.elements(<span class="string">&quot;employee&quot;</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element employee:employees)&#123;</span><br><span class="line">                <span class="comment">//element方法用于获取唯一的子节点对象</span></span><br><span class="line">                Element name = employee.element(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">                <span class="comment">//getText方法用于获取标签文本</span></span><br><span class="line">                String empName = name.getText();</span><br><span class="line">                System.out.println(empName);</span><br><span class="line">                <span class="comment">//elementText方法用于获取子标签的文本</span></span><br><span class="line">                System.out.println(employee.elementText(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">                <span class="comment">//用于获取节点的属性</span></span><br><span class="line">                Attribute att = employee.attribute(<span class="string">&quot;no&quot;</span>);</span><br><span class="line">                System.out.println(att.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        HrReader reader = <span class="keyword">new</span> HrReader();</span><br><span class="line">        reader.readXml();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="利用Dom4j更新XML">利用Dom4j更新XML</h3><p>idea里格式化代码快捷键</p><blockquote><p>ctrl+shift+L</p></blockquote><p>下面这段代码利用Dom4j对XML文件进行了写入操作</p><h3 id="XPath路径表达式">XPath路径表达式</h3><blockquote><p>XPath路径表达式是XML文档中查找数据的语言</p><p>掌握XPath可以极大的提高在提起数据时的开发效率</p><p>学习XPath本质就是掌握各种形式表达式的技巧</p></blockquote><h3 id="XPath基本表达式">XPath基本表达式</h3><p>最基本表达式</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点的所有子节点</td></tr><tr><td>/</td><td>从根节点选取</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑他们的位置</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>…</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr></tbody></table><h3 id="XPath基本表达式案例">XPath基本表达式案例</h3><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>bookstore</td><td>选取bookstore元素的所有子节点</td></tr><tr><td>/bookstore</td><td>选取根元素bookstore注释:假如路径起始于正斜杠(/),则此路径始终代表到某元素的绝对路径</td></tr><tr><td>bookstore/book</td><td>选取属于bookstore的子元素的所有book元素</td></tr><tr><td>//book</td><td>选取所有book子元素，而不管它们在文档中的位置</td></tr><tr><td>bookstore//book</td><td>选择属于bookstore元素的后代的所有book元素，而不管他们位于bookstore之下的什么位置</td></tr><tr><td>//@lang</td><td>选取名为lang的所有属性</td></tr></tbody></table><h3 id="XPath谓语表达式">XPath谓语表达式</h3><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/bookstore/book[1]</td><td>选取属于bookstore子元素的第一个book元素</td></tr><tr><td>/bookstore/book[last()]</td><td>选取属于bookstore子元素的最后一个book元素</td></tr><tr><td>/bookstore/book[last()-1]</td><td>选取属于bookstore子元素的倒数第二个book元素</td></tr><tr><td>/bookstore/book[position()&lt;3]</td><td>选取最前面的两个属于bookstore元素的子元素的book元素</td></tr><tr><td>//title[@lang]</td><td>选取所有拥有名为lang的属性的title元素</td></tr><tr><td>//title[@lang=‘eng’]</td><td>选取所有title元素，且这些元素拥有值为eng的lang属性</td></tr><tr><td>/bookstore/book[price&gt;35.00]</td><td>选取bookstore元素的所有book元素，且其中的price元素的值需大于35.00</td></tr><tr><td>/bookstore/book[price&gt;35.00]/title</td><td>选取bookstore元素中的book元素的所有title元素，且其中的price元素需大于35.00</td></tr></tbody></table><h3 id="Jaxen介绍">Jaxen介绍</h3><ol><li>Jaxen是一个Java编写的开源的XPath库。这是适应多种不同的对象模型，包括DOM，XOM，dom4j和JDOM。</li><li>Dom4j底层依赖Jaxen实现XPath查询</li><li>Jaxen下载地址:jaxen.codehaus.org</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> dom4j;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Node;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XPathTestor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">XPath</span><span class="params">(String xpathExp)</span></span>&#123;</span><br><span class="line">        String file = <span class="string">&quot;D:/javase/untitled/src/hr.xml&quot;</span>;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Document doc = reader.read(file);</span><br><span class="line">            List&lt;Node&gt; nodes = doc.selectNodes(xpathExp);</span><br><span class="line">            <span class="keyword">for</span>(Node node:nodes)&#123;</span><br><span class="line">                Element emp = (Element)node;</span><br><span class="line">                System.out.println(emp.attributeValue(<span class="string">&quot;no&quot;</span>));</span><br><span class="line">                System.out.println(emp.elementText(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">                System.out.println(emp.elementText(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">                System.out.println(emp.elementText(<span class="string">&quot;salary&quot;</span>));</span><br><span class="line">                System.out.println(<span class="string">&quot;============================&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        XPathTestor xPathTestor = <span class="keyword">new</span> XPathTestor();</span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;/hr/employee&quot;);</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee&quot;);</span></span><br><span class="line">        <span class="comment">//查询工资小于4000的员工信息</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[salary&lt;4000]&quot;);</span></span><br><span class="line">        <span class="comment">//查询李铁柱的信息</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[name=&#x27;李铁柱&#x27;]&quot;);</span></span><br><span class="line">        <span class="comment">//利用属性筛选</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[@no=8105]&quot;);</span></span><br><span class="line">        <span class="comment">//编号比较小的节点</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[1]&quot;);</span></span><br><span class="line"><span class="comment">//        xPathTestor.XPath(&quot;//employee[last()]&quot;);</span></span><br><span class="line"><span class="comment">//        获取前两名</span></span><br><span class="line">        xPathTestor.XPath(<span class="string">&quot;//employee[position()&lt;3]&quot;</span>);</span><br><span class="line"><span class="comment">//        获取第一和第二</span></span><br><span class="line">        xPathTestor.XPath(<span class="string">&quot;//employee[1]|//employee[2]&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;XML的用途&quot;&gt;XML的用途&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;1.Java程序的配置描述文件&lt;/p&gt;
&lt;p&gt;2.用于保存程序的产生的数据&lt;/p&gt;
&lt;p&gt;3.网络间的数据传输&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;XML的文档结构&quot;&gt;XML的</summary>
      
    
    
    
    <category term="JavaEE" scheme="http://example.com/categories/JavaEE/"/>
    
    
  </entry>
  
  <entry>
    <title>Java并发基础</title>
    <link href="http://example.com/2022/01/07/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/"/>
    <id>http://example.com/2022/01/07/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-07T08:10:47.000Z</published>
    <updated>2022-01-11T07:42:36.247Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是线程和进程">什么是线程和进程</h3><p><strong>进程是程序的一次执行过程</strong>，<strong>是系统运行程序的基本单位</strong>，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。在 windows 中通过查看任务管理器的方式，我们就可以清楚看到 window 当前运行的进程（.exe 文件的运行）。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p><p><strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是线程和进程&quot;&gt;什么是线程和进程&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;进程是程序的一次执行过程&lt;/strong&gt;，&lt;strong&gt;是系统运行程序的基本单位&lt;/strong&gt;，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。在 Java 中，</summary>
      
    
    
    
    <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>DML-数据库定义语言</title>
    <link href="http://example.com/2022/01/07/DML-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2022/01/07/DML-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</id>
    <published>2022-01-07T07:10:10.000Z</published>
    <updated>2022-01-09T09:30:37.795Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库操作语言">数据库操作语言</h3><p>添加操作:insert into…</p><h4 id="添加一条记录">添加一条记录</h4><p>a.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名(字段名，字段名，....) <span class="keyword">values</span> (数据<span class="number">1</span>，数据<span class="number">2</span>，...)</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (name，age) <span class="keyword">values</span> (‘TOM’，<span class="number">18</span>)</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> student (name) <span class="keyword">values</span> (<span class="string">&#x27;Jerry&#x27;</span>);</span><br></pre></td></tr></table></figure><p>b.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 <span class="keyword">values</span> (数据<span class="number">1</span>,数据<span class="number">2</span>,数据...);</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">user</span> <span class="keyword">values</span> (&quot;rose&quot;)</span><br></pre></td></tr></table></figure><p><strong>注意:用方法b有多少个字段，就给多少个值</strong></p><p>设置字段编码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> 字段名 gbk;</span><br></pre></td></tr></table></figure><h4 id="添加多条记录">添加多条记录</h4><p>a.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> 表名 (字段名,字段名,....) <span class="keyword">values</span> (数据<span class="number">1</span>,数据<span class="number">2</span>,...),(数据<span class="number">1</span>,数据<span class="number">2</span>,...);</span><br></pre></td></tr></table></figure><h4 id="date-datetime-timestamp">date,datetime,timestamp</h4><h4 id="修改操作">修改操作</h4>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库操作语言&quot;&gt;数据库操作语言&lt;/h3&gt;
&lt;p&gt;添加操作:	insert into…&lt;/p&gt;
&lt;h4 id=&quot;添加一条记录&quot;&gt;添加一条记录&lt;/h4&gt;
&lt;p&gt;a.&lt;/p&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>K个一组反转链表</title>
    <link href="http://example.com/2022/01/07/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://example.com/2022/01/07/K%E4%B8%AA%E4%B8%80%E7%BB%84%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</id>
    <published>2022-01-07T04:24:03.000Z</published>
    <updated>2022-01-07T04:28:54.946Z</updated>
    
    <content type="html"><![CDATA[<h3 id="K个一组反转链表">K个一组反转链表</h3><blockquote><p>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p></blockquote><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [1,2,3,4,5], k = 2</span><br><span class="line">输出：[2,1,4,3,5]</span><br></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode() &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span></span><br><span class="line"><span class="comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseKGroup</span><span class="params">(ListNode head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//如果链表为空，直接返回</span></span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>)<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        ListNode a = head;ListNode b = head;</span><br><span class="line">        <span class="comment">//搜寻节点b的位置</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;k;i++)&#123;</span><br><span class="line">            <span class="comment">//base case</span></span><br><span class="line">            <span class="keyword">if</span>(b==<span class="keyword">null</span>)<span class="keyword">return</span> head;</span><br><span class="line">            b=b.next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//反转了a到b的节点</span></span><br><span class="line">        ListNode HeadNode = reverse(a,b);</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        a.next = reverseKGroup(b,k);</span><br><span class="line">        <span class="keyword">return</span> HeadNode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反转链表从a到b的节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverse</span><span class="params">(ListNode a,ListNode b)</span></span>&#123;</span><br><span class="line">        ListNode pre = a;ListNode cur = a;</span><br><span class="line">        ListNode sub = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span>(cur!=b)&#123;</span><br><span class="line">            pre = pre.next;</span><br><span class="line">            cur.next = sub;</span><br><span class="line">            sub = cur;</span><br><span class="line">            cur = pre;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sub.val);</span><br><span class="line">        <span class="keyword">return</span> sub;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;K个一组反转链表&quot;&gt;K个一组反转链表&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。&lt;/p&gt;
&lt;p&gt;k 是一个正整数，它的值小于或等于链表的长度。&lt;/p&gt;
&lt;p&gt;如果节点总数不是 k 的整数倍，那么请将最</summary>
      
    
    
    
    <category term="Leetcode刷题" scheme="http://example.com/categories/Leetcode%E5%88%B7%E9%A2%98/"/>
    
    
  </entry>
  
  <entry>
    <title>GET请求和POST请求</title>
    <link href="http://example.com/2022/01/06/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82/"/>
    <id>http://example.com/2022/01/06/GET%E8%AF%B7%E6%B1%82%E5%92%8CPOST%E8%AF%B7%E6%B1%82/</id>
    <published>2022-01-06T14:26:24.000Z</published>
    <updated>2022-01-06T15:19:21.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="定义">定义</h3><p>无论是<strong>GET</strong>还是<strong>POST</strong>，统一由视图函数接收请求，通过判断<strong>request.method</strong>区分具体的请求动作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if request.method == &#x27;GET&#x27;:</span><br><span class="line">处理GET请求时的业务逻辑</span><br><span class="line">elif request.method == &#x27;POST&#x27;:</span><br><span class="line">处理POST请求时的业务逻辑</span><br><span class="line">else:</span><br><span class="line">其他请求业务逻辑</span><br></pre></td></tr></table></figure><h3 id="GET请求">GET请求</h3><p><strong>GET</strong>请求动作，一般用于向服务器获取数据</p><p>能够产生<strong>GET</strong>请求的场景</p><p>​-浏览器地址栏输入URL，回车后</p><p>​-<a href="地址?参数=值&参数=值"></p><p>​-form表单中的method为GET</p><p><strong>GET</strong>请求方式中，如果有数据需要传给服务器，通常会用查询字符串(Query String)传递[不要传递敏感数据]</p><p>URL格式:xxx?参数1:值1&amp;参数2:值2</p><p>​-如:<a href="http://127.0.0.1/page1?a=100&amp;b=200">http://127.0.0.1/page1?a=100&amp;b=200</a></p><p>服务器端接收数据</p><p>​获取客户端请求GET请求提交的数据</p><h4 id="方法实例">方法实例</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.GET[<span class="string">&#x27;参数名&#x27;</span>]</span><br><span class="line">request.GET(<span class="string">&#x27;参数名&#x27;</span>,<span class="string">&#x27;默认值&#x27;</span>)</span><br><span class="line">request.GET.getlist(<span class="string">&#x27;参数名&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;定义&quot;&gt;定义&lt;/h3&gt;
&lt;p&gt;无论是&lt;strong&gt;GET&lt;/strong&gt;还是&lt;strong&gt;POST&lt;/strong&gt;，统一由视图函数接收请求，通过判断&lt;strong&gt;request.method&lt;/strong&gt;区分具体的请求动作&lt;/p&gt;
&lt;figure c</summary>
      
    
    
    
    <category term="django学习" scheme="http://example.com/categories/django%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
  <entry>
    <title>DDL-数据库定义语言</title>
    <link href="http://example.com/2022/01/06/DDL-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/"/>
    <id>http://example.com/2022/01/06/DDL-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%9A%E4%B9%89%E8%AF%AD%E8%A8%80/</id>
    <published>2022-01-06T10:08:05.000Z</published>
    <updated>2022-01-07T07:07:29.738Z</updated>
    
    <content type="html"><![CDATA[<h3 id="查看有哪些数据库">查看有哪些数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases;</span><br></pre></td></tr></table></figure><h3 id="创建一个新的数据库">创建一个新的数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="查看数据库创建细节">查看数据库创建细节</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">create</span> database 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="删除数据库">删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="使用数据库名字">使用数据库名字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use 数据库名字;</span><br></pre></td></tr></table></figure><h3 id="查看数据库的表">查看数据库的表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show tables;</span><br></pre></td></tr></table></figure><h3 id="创建一张新的表">创建一张新的表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">字段名变量类型,</span><br><span class="line">字段名变量类型,</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> person(</span><br><span class="line">name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">age <span class="type">int</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h3 id="常见数据类型">常见数据类型</h3><p>int</p><p>decimal(5,2)-5是精度，小数点后面2位</p><p>date</p><p>datatime</p><p>timestamp</p><p>varchar(20)</p><h3 id="查看表的结构">查看表的结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">desc</span> 表名</span><br></pre></td></tr></table></figure><h3 id="在原有的基础之上增加一个新的字段">在原有的基础之上增加一个新的字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 <span class="keyword">add</span> 字段名 数据类型;</span><br></pre></td></tr></table></figure><h3 id="在原有的基础之上修改字段的名字">在原有的基础之上修改字段的名字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 原字段名 新字段名数据类型;</span><br></pre></td></tr></table></figure><h3 id="在原表基础之上，修改字段的数据类型">在原表基础之上，修改字段的数据类型</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 change 原字段名 原字段名新的数据类型;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> 表名 modify 原字段名 新的数据类型;</span><br></pre></td></tr></table></figure><h3 id="删除某一个字段">删除某一个字段</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 drop 字段名;</span><br><span class="line">alter table person drop gender;</span><br></pre></td></tr></table></figure><h3 id="修改表的名字">修改表的名字</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename <span class="keyword">table</span> 原表名 <span class="keyword">to</span> 新表名;</span><br></pre></td></tr></table></figure><h3 id="删除指定的表">删除指定的表</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop table 表名;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;查看有哪些数据库&quot;&gt;查看有哪些数据库&lt;/h3&gt;
&lt;figure class=&quot;highlight sql&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>SQL语句介绍</title>
    <link href="http://example.com/2022/01/06/SQL%E8%AF%AD%E5%8F%A5%E4%BB%8B%E7%BB%8D/"/>
    <id>http://example.com/2022/01/06/SQL%E8%AF%AD%E5%8F%A5%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-01-06T09:59:34.000Z</published>
    <updated>2022-01-06T10:07:46.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="SQL介绍">SQL介绍</h3><table><thead><tr><th>DDL</th><th>数据库定义语言，这里边的SQL语言，主要用于操作数据库和表的结构</th></tr></thead><tbody><tr><td>DML</td><td>数据库定义语言，这里边的SQL语言，主要用于操作数据库的表的数据的增删改查</td></tr><tr><td>DQL</td><td>数据库定义语言，这里边的SQL语言，主要用于操作数据库的表的数据的查询</td></tr><tr><td>DCL</td><td>数据库定义语言，这里边的SQL语言，主要用于操作数据库的用户的账号密码，权限和访问级别的</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;SQL介绍&quot;&gt;SQL介绍&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DDL&lt;/th&gt;
&lt;th&gt;数据库定义语言，这里边的SQL语言，主要用于操作数据库和表的结构&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;DML&lt;/t</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>MySQL服务启动</title>
    <link href="http://example.com/2022/01/06/MySQL%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/"/>
    <id>http://example.com/2022/01/06/MySQL%E6%9C%8D%E5%8A%A1%E5%90%AF%E5%8A%A8/</id>
    <published>2022-01-06T09:46:34.000Z</published>
    <updated>2022-01-06T10:00:17.344Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qqwangfan/article/details/90905642">MySQL服务的启动</a></p><p>在DOS下输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开启MySQL</span><br><span class="line">$net start MySQL80(服务名)</span><br><span class="line">关闭MySQL</span><br><span class="line">$net stop MySQL80(服务名)</span><br></pre></td></tr></table></figure><h3 id="MySQL的登录与退出">MySQL的登录与退出</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$mysql -u root -p</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://blog.csdn.net/qqwangfan/article/details/90905642&quot;&gt;MySQL服务的启动&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在DOS下输入&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;</summary>
      
    
    
    
    <category term="MySQL" scheme="http://example.com/categories/MySQL/"/>
    
    
  </entry>
  
  <entry>
    <title>==和equals</title>
    <link href="http://example.com/2022/01/06/%E5%92%8Cequals/"/>
    <id>http://example.com/2022/01/06/%E5%92%8Cequals/</id>
    <published>2022-01-06T08:13:13.000Z</published>
    <updated>2022-01-07T15:08:28.527Z</updated>
    
    <content type="html"><![CDATA[<h3 id="">==</h3><blockquote><p>==对于基本数据类型来说，比较的是数据的值</p><p>==对于引用数据类型来说，比较的是对象的内存地址</p></blockquote><h3 id="equals">equals()</h3><blockquote><p>不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p></blockquote><p>equals()方法存在两种使用情况:</p><p><strong>类没有覆盖equals()方法</strong>:通过equals()方法比较该类的两个对象时，等价于通过&quot;==&quot;比较这两个对象。使用的默认是<strong>Object</strong>类的**equals()**方法</p><p><strong>类覆盖了equals()方法</strong>:一般我们都覆盖 <code>equals()</code>方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。</p><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，因为 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是对象的值。</p><p>当创建 <code>String</code> 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 <code>String</code> 对象。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;&quot;&gt;==&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;==对于基本数据类型来说，比较的是数据的值&lt;/p&gt;
&lt;p&gt;==对于引用数据类型来说，比较的是对象的内存地址&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;equals&quot;&gt;equals()&lt;/h3&gt;
&lt;blo</summary>
      
    
    
    
    <category term="JavaSE" scheme="http://example.com/categories/JavaSE/"/>
    
    
  </entry>
  
  <entry>
    <title>请求及响应</title>
    <link href="http://example.com/2022/01/06/%E8%AF%B7%E6%B1%82%E5%8F%8A%E5%93%8D%E5%BA%94/"/>
    <id>http://example.com/2022/01/06/%E8%AF%B7%E6%B1%82%E5%8F%8A%E5%93%8D%E5%BA%94/</id>
    <published>2022-01-06T06:55:04.000Z</published>
    <updated>2022-01-06T14:25:11.804Z</updated>
    
    <content type="html"><![CDATA[<h3 id="HTTP协议的请求和响应">HTTP协议的请求和响应</h3><blockquote><p>请求是指浏览器端通过HTTP协议发送给服务器端的数据</p><p>响应是指服务器端接收到请求后做相应的处理后再返回给浏览器端的数据</p></blockquote><h3 id="请求中的方法">请求中的方法</h3><p>根据HTTP协议，HTTP协议可使用多种方法</p><p>HTTP1.0定义了三种请求方法:<strong>GET</strong>,<strong>POST</strong>和<strong>HEAD</strong>方法</p><p>HTTP1.1新增了五种请求方法:<strong>OPTIONS</strong>,<strong>PUT</strong>,<strong>DELETE</strong>,<strong>TRACE</strong>和<strong>CONNECT</strong>方法</p><table><thead><tr><th>序号</th><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>1</td><td>GET</td><td>请求指定的页面信息，并返回实体主题</td></tr><tr><td>2</td><td>HEAD</td><td>类似于POST请求，只不过访问的请求中没有具体的内容，用于获取表头</td></tr><tr><td>3</td><td>POST</td><td>向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。POST请求可能会导致新的资源的建立或者旧资源的修改。(所以Post用来增资源)</td></tr><tr><td>4</td><td>PUT</td><td>从客户端向服务器传送的数据取代指定的文档的内容</td></tr><tr><td>5</td><td>DELETE</td><td>请求服务器删除指定的页面</td></tr><tr><td>6</td><td>CONNECT</td><td>允许将连接方式改为管道方式的代理服务器</td></tr><tr><td>7</td><td>OPTIONS</td><td>允许客户端查看服务器的性能</td></tr><tr><td>8</td><td>TRACE</td><td>回显服务器收到的请求，主要用于测试或者诊断</td></tr></tbody></table><h3 id="Django中的请求">Django中的请求</h3><p>请求在Django中实则就是<strong>视图函数中的第一个参数</strong>，即<strong>HttpRequest</strong>对象</p><p>Django接收到HTTP协议的对象后，会根据请求数据报文创建<strong>HttpRequest</strong>对象</p><p><strong>HttpRequest</strong>对象通过属性描述了<strong>请求的所有相关信息</strong></p><h3 id="Django中请求的属性和方法">Django中请求的属性和方法</h3><p><strong>path_info</strong>:URL字符串</p><p><strong>method</strong>:字符串，表示HTTP请求方法，常用值:‘<strong>GET</strong>’,‘<strong>POST</strong>’</p><h3 id="HTTP响应状态码">HTTP响应状态码</h3><p><strong>HTTP</strong>状态码的英文为:HTTP Status Code</p><p>下面是常见的HTTP状态码</p><p>-200-请求成功</p><p>-301-永久重定向-资源或者网页被转移到其他URL</p><p>-302-临时重定向</p><p>-404-访问的资源(网页)不存在</p><p>-500-内部服务器错误</p><p>HTTP状态码有<strong>三个十进制数字</strong>组成，第一个十进制定义了<strong>状态码的类型</strong>，后两个数字没有分类的作用。HTTP状态码共分为5种类型</p><table><thead><tr><th>分类</th><th>分类描述</th></tr></thead><tbody><tr><td>1XX</td><td>信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td>2XX</td><td>成功，操作被成功接收并处理</td></tr><tr><td>3XX</td><td>重定向，需要进一步的操作以完成请求</td></tr><tr><td>4XX</td><td>客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td>5XX</td><td>服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><h3 id="Django中的请求的属性与方法">Django中的请求的属性与方法</h3><table><thead><tr><th>path_info</th><th>URL字符串</th></tr></thead><tbody><tr><td>mathod</td><td>字符串，表示HTTP请求方法，常用值:‘GET’，‘POST’</td></tr><tr><td>GET</td><td>QueryDict查询字典的对象，包含get请求方式的所有数据</td></tr><tr><td>POST</td><td>QueryDict查询字典的对象，包含post请求方式的所有数据</td></tr><tr><td>FILES</td><td>类似于字典的对象，包含所有的上传文件信息</td></tr><tr><td>COOKIES</td><td>Python字典，包含所有的cookie，键和值都为字符串</td></tr><tr><td>session</td><td>似于字典的对象，表示当前的会话</td></tr><tr><td>body</td><td>字符串，请求体的内容(POST或者PUT)</td></tr><tr><td>scheme</td><td>请求协议(‘HTTP’/‘HTTPS’)</td></tr><tr><td>request.get_full_path()</td><td>请求的完整路径</td></tr><tr><td>request.META</td><td>请求中的元数据(消息头)</td></tr><tr><td>request.META[‘REMOTE_ADDR’]</td><td>客户端地址</td></tr></tbody></table><h3 id="Django中的响应对象">Django中的响应对象</h3><p>构造函数格式:</p><p>​HttpResponse(content=响应体，content_type=响应体数据类型(默认值HTML)，status=状态码(默认值200))</p><p>作用:</p><p>​向客户端浏览器返回响应，同时携带响应体内容</p><h3 id="常用的Content-Type如下">常用的Content-Type如下</h3><table><thead><tr><th>Content-Type</th><th>含义</th></tr></thead><tbody><tr><td>text/HTML</td><td>默认的，HTML文件</td></tr><tr><td>text/plain</td><td>纯文本</td></tr><tr><td>text/css</td><td>css文件</td></tr><tr><td>text/javascript</td><td>javascript文件</td></tr><tr><td>multipart/form-data</td><td>文件提交</td></tr><tr><td>application/json</td><td>json传输</td></tr><tr><td>application/xml</td><td>xml文件</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;HTTP协议的请求和响应&quot;&gt;HTTP协议的请求和响应&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;请求是指浏览器端通过HTTP协议发送给服务器端的数据&lt;/p&gt;
&lt;p&gt;响应是指服务器端接收到请求后做相应的处理后再返回给浏览器端的数据&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="django学习" scheme="http://example.com/categories/django%E5%AD%A6%E4%B9%A0/"/>
    
    
  </entry>
  
</feed>
